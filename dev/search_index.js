var documenterSearchIndex = {"docs":
[{"location":"types/#QuantReg.jl-Types-1","page":"Types","title":"QuantReg.jl Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"The QuantReg.jl package introduces four types: QuantRegFit, QuantRegInf, QuantRegModel, and QuantRegModels. For most users, a deep understanding of these types is unnecessary, but the structure of these types will be helpful for advanced users, students investigating the properties of quantile regression, or developers wishing to extend the package.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"These four types work together as follows: a QuantRegModel is an immutable object and contains all of the specification necessary to fit and compute inference for a model plus a QuantRegFit andQuantRegInf objects to store the results of fitting the model and computing inference, respectively. A QuantRegModels object stores multiple QuantRegModel objects, indexed by their τ values; note that a QuantRegModels object cannot contain multple QuantRegModel objects with the same τ value.","category":"page"},{"location":"types/#QuantRegFit-1","page":"Types","title":"QuantRegFit","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegFit objects store the results of fitting a quantile regression model and are mutable. Each instance contains the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"computed: denotes whether or not the parent model has been fit\ncoef: stores the coefficients for a fitted model or nothing if   model hasn't been fit\nresid: stores the residuals for each observation or nothing if   the model hasn't been fit\ndual: stores the solution to the dual problem if the fitting   method produces the dual solution or nothing if the model hasn't been fit or the fitting   method does not produce the dual solution\nyhat: stores the fitted values for the dataset used to build the   model or nothing if the model hasn't been fit","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegFit has one construtor, the default constructor in which all field values are specified directly. QuantRegFit objects are primarily constructed in the creation of QuantRegModel objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegFit","category":"page"},{"location":"types/#QuantReg.QuantRegFit","page":"Types","title":"QuantReg.QuantRegFit","text":"QuantReg.QuantRegFit(computed::Bool, coef::Union{Vector{<:Number}, Nothing},\n                     resid::Union{Vector{<:Number}, Nothing}, \n                     dual::Union{Vector{<:Number}, Nothing},\n                     yhat::Union{Vector{<:Number}, Nothing})\n\nStores results of fitting a quantile regression model.\n\ncoef, resid, dual, and yhat should be set to nothing until a model is fit.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, there is a method to create deep copies of QuantRegFit objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegFit)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantReg.QuantRegFit}","page":"Types","title":"Base.deepcopy","text":"deepcopy(fit::QuantRegFit)\n\nCreate a deep copy of fit.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegInf-1","page":"Types","title":"QuantRegInf","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"Similarly, QuantRegInf objects store the results of computing inference for a quantile regression model and are mutable. Each instance contains the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"computed: denotes whether or not inference has been computed for the parent model\nlowerci: lower bounds for the specified confidence intervals or nothing if inference   hasn't been computed for the model; a (k x 1) matrix unless inference is computed via    rank test inversion and interpolate is set to false, in which case a (k x 2) matrix\nupperci: upper bounds for the specified confidence intervals or nothing if inference   hasn't been computed for the model; a (k x 1) matrix unless inference is computed via   rank test inversion and interpolate is set to false, in which case a (k x 2) matrix\nσ: standard errors for the coefficients or nothing if inference hasn't been computed   for the model or is calculated via a rank test inversion\nteststat: t or z statistics for the coefficients or nothing if inference hasn't been   computed for the model or is calculated via a rank test inversion\np: p values for the coefficients or nothing if inference hasn't been computed for the   model or is calculated via a rank test inversion","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegInf also has one construtor, the default constructor in which all field values are specified directly. QuantRegFit objects are primarily constructed in the creation of QuantRegModel objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegInf","category":"page"},{"location":"types/#QuantReg.QuantRegInf","page":"Types","title":"QuantReg.QuantRegInf","text":"QuantReg.QuantRegInf(computed::Bool,\n                     lowerci::Union{Nothing, Vector{<:Number}, Matrix{<:Number}}\n                     upperci::Union{Nothing, Vector{<:Number}, Matrix{<:Number}}\n                     σ::Union{Nothing, Vector{<:Number}}\n                     teststat::Union{Nothing, Vector{<:Number}}\n                     p::Union{Nothing, Vector{<:Number}})\n\nStores results of computing inference for a quantile regression model.\n\nlowerci, upperci, σ, teststat, and p should be set to nothing until inference is computed.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, there is a method to create deep copies of QuantRegInf objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegInf)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantReg.QuantRegInf}","page":"Types","title":"Base.deepcopy","text":"deepcopy(inf::QuantRegInf)\n\nCreate a deep copy of inf.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegModel-1","page":"Types","title":"QuantRegModel","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegModel is the type with which end users are most likely to interact. QuantRegModel objects are immutable and contain the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"formula: the formula to fit the data\ndata: DataFrame object containing data to fit the model with\nmf: ModelFrame object created by applying formula to data\nmm: ModelMatrix object created from mf\nτ: quantile to fit the model at\nfitmethod: the algorithm/method to fit the model; available options are:\n\"br\": fit using Barrodale-Roberts simplex (default method)\n\"fn\": Fit using Frisch-Newton algorithm\n\"gurobi\": Fit using Gurobi (must have Gurobi installed)\ninvers: if true, compute confidence intervals by inverting a rank test (only recommended   for datasets with <= 1000 observations); otherwise, use an asymptotic esimtate of the   covariance matrix\nα: size of the test for computing inference\nhs: if true, use Hall Sheather bandwidth when computing sparsity estimates (not   applicable if inference is calculated via rank test inversion with iid regression errors)\niid:  if true, assume regression errors are iid; otherwise, assume that the conditional   quantile function is locally (in tau) linear (in x)\ninterpolate: if true, interpolate the confidence intervals produced by rank test   inversion inference; otherwise report values just above and just below each cutoff (only   applicable if inference is calculated via rank test inversion)\ntcrit: if true, use a Student's t distribution for calculating critical points;    otherwise use a normal distribution\nfit: QuantRegFit object storing the results of fitting the model\ninf: QuantRegInf object storing the results of computing inference for the model","category":"page"},{"location":"types/#Constructors-1","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"There are multiple ways to construct a QuantRegModel object. The most relevant one for end users accepts a formula and dataset as positional arguments and model specifications as keyword arguments. Depending on the passed arguments, the constructor intelligently choses defaults for unspecified fields as described below and constructs empty QuantRegFit and QuantRegInf objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel(::StatsModels.FormulaTerm, ::DataFrames.DataFrame; ::Number,\n                       ::String, ::Union{Nothing, Bool}, ::Number, ::Bool,\n                       ::Union{Nothing, Bool}, ::Bool, ::Bool)","category":"page"},{"location":"types/#QuantReg.QuantRegModel-Tuple{FormulaTerm,DataFrame}","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(formula::FormulaTerm, data::DataFrame; τ::Number=0.5,\n              fitmethod::String=\"br\",invers::Union{Nothing, Bool}=nothing,\n              α::Number=0.05, hs::Bool=true, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Bool=true, tcrit::Bool=true)\n\nConstruct a quantile regression model at the τth quantile fitting data according to formula.\n\nIn any call, formula and data must be set. The logic for setting values of unspecified parameters is as follows:\n\nτ: default is 0.5, i.e. median regression\nfitmethod: default method is the Barrodale-Roberts simplex\ninvers: default setting is true for datasets with 1000 or fewer observations and false   for larger datasets\nα: default setting is 0.05\nhs: default is true; always set to true when computing inference via rank test inversion\niid: default is true if computing inference via rank test inversion and false otherwise\ninterpolate: default is true\ntcrit: default is true\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, one can construct a new QuantRegModel object from an existing QuantRegModel object by specifying parameters to change.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel(::QuantRegModel; ::Union{Nothing, Number}, ::Union{Nothing, String},\n              ::Union{Nothing, Bool}, ::Union{Nothing, Number}, hs::Union{Nothing, Bool},\n              ::Union{Nothing, Bool}, ::Union{Nothing, Bool}, ::Union{Nothing, Bool})","category":"page"},{"location":"types/#QuantReg.QuantRegModel-Tuple{QuantRegModel}","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(model::QuantRegModel; τ::Union{Nothing, Number}=nothing,\n              fitmethod::Union{Nothing, String}=nothing,\n              invers::Union{Nothing, Bool}=nothing, α::Union{Nothing, Number}=nothing,\n              hs::Union{Nothing, Bool}=nothing, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Union{Nothing, Bool}=nothing,\n              tcrit::Union{Nothing, Bool}=nothing)\n\nConstruct a new quantile regression model by changing one or more parameters in an existing model.\n\nIf τ or method are unchanged, then the model fit is copied from the passed model but the model inf is not. Otherwise, neither is copied.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"One particularly convient use caase for this constructor would be changing the test size or inference type for an existing model. For example, consider generating the following model:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Suppose after fitting this model, the user wants to calculate 90% confidence intervals without recomputing the model fit. Such a change is nontrivial because the Hall-Sheather bandwidth depends on the the confidence interval size. To compute this change, the user could employ the above constructor as follows:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> newmodel = QuantRegModel(model; α=0.10) # Generate model with new test size\njulia> compute_inf!(newmodel) # Compute inference for the modified model in-place","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Finally, the QuantRegModel object also has a default constructor. Use of the default constructor is strongly discouraged.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel","category":"page"},{"location":"types/#QuantReg.QuantRegModel","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(formula::FormulaTerm, data::DataFrame, mf::ModelFrame, mm::ModelMatrix,\n              τ::Number, fitmethod::String, invers::Bool, α::Number, hs::Bool,\n              iid::Bool, interpolate::Bool, tcrit::Bool, fit::QuantRegFit,\n              inf::QuantRegInfe)\n\nContains a quantile regression model at the τth quantile fitting data according to formula.\n\nUse of this default constructor is not recommended. If rank test inversion is used to compute inference, then the Hall-Sheather bandwidth flag will always be set to true, overriding user input.\n\n\n\n\n\n","category":"type"},{"location":"types/#Methods-1","page":"Types","title":"Methods","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"There is a method to create a deep copy of a QuantRegModel object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegModel)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantRegModel}","page":"Types","title":"Base.deepcopy","text":"deepcopy(model::QuantRegModel)\n\nCreate a deep copy of model (excluding data and formula).\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"There are also methods for the following StatsBase abstractions:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"StatsBase.coef\nStatsBase.coefnames\nStatsBase.coeftable\nStatsBase.confint(::QuantRegModel)\nStatsBase.dof\nStatsBase.dof_residual\nStatsBase.fitted\nStatsBase.isfitted\nStatsBase.islinear\nStatsBase.nobs\nStatsBase.modelmatrix\nStatsBase.response\nStatsBase.responsename\nStatsBase.residuals","category":"page"},{"location":"types/#StatsBase.coef","page":"Types","title":"StatsBase.coef","text":"coef(obj::StatisticalModel)\n\nReturn the coefficients of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.coefnames","page":"Types","title":"StatsBase.coefnames","text":"coefnames(obj::StatisticalModel)\n\nReturn the names of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.coeftable","page":"Types","title":"StatsBase.coeftable","text":"coeftable(obj::StatisticalModel; level::Real=0.95)\n\nReturn a table of class CoefTable with coefficients and related statistics. level determines the level for confidence intervals (by default, 95%).\n\n\n\n\n\ncoeftable(model::QuantRegModel)\n\nReturn a table of class CoefTable with coefficients and related statistics.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.confint-Tuple{QuantRegModel}","page":"Types","title":"StatsBase.confint","text":"confint(obj::StatisticalModel; level::Real=0.95)\n\nCompute confidence intervals for coefficients, with confidence level level (by default 95%).\n\n\n\n\n\n","category":"method"},{"location":"types/#StatsBase.dof","page":"Types","title":"StatsBase.dof","text":"dof(obj::StatisticalModel)\n\nReturn the number of degrees of freedom consumed in the model, including when applicable the intercept and the distribution's dispersion parameter.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.dof_residual","page":"Types","title":"StatsBase.dof_residual","text":"dof_residual(obj::RegressionModel)\n\nReturn the residual degrees of freedom of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.fitted","page":"Types","title":"StatsBase.fitted","text":"fitted(obj::RegressionModel)\n\nReturn the fitted values of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.isfitted","page":"Types","title":"StatsBase.isfitted","text":"isfitted(obj::StatisticalModel)\n\nIndicate whether the model has been fitted.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.islinear","page":"Types","title":"StatsBase.islinear","text":"islinear(obj::StatisticalModel)\n\nIndicate whether the model is linear.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.nobs","page":"Types","title":"StatsBase.nobs","text":"nobs(obj::StatisticalModel)\n\nReturn the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.modelmatrix","page":"Types","title":"StatsBase.modelmatrix","text":"modelmatrix(obj::RegressionModel)\n\nReturn the model matrix (a.k.a. the design matrix).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.response","page":"Types","title":"StatsBase.response","text":"response(obj::RegressionModel)\n\nReturn the model response (a.k.a. the dependent variable).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.responsename","page":"Types","title":"StatsBase.responsename","text":"responsename(obj::RegressionModel)\n\nReturn the name of the model response (a.k.a. the dependent variable).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.residuals","page":"Types","title":"StatsBase.residuals","text":"residuals(obj::RegressionModel)\n\nReturn the residuals of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"Types","title":"Types","text":"As well as a method to nicely print the results of a model:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.show(::IO, ::QuantRegModel)","category":"page"},{"location":"types/#Base.show-Tuple{IO,QuantRegModel}","page":"Types","title":"Base.show","text":"show(io::IO, model::QuantRegModel)\n\nDisplay a quantreg model.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegModels-1","page":"Types","title":"QuantRegModels","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.jl also contains a QuantRegModels type that enables users to store multiple models at different τ values. This type is a hybrid between a dictionary and a list so that models are always indexed by the τ value for which they are fit. A single QuantRegModels object cannot contain multiple models with the same τ value. ","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"note: Note\nThe primary intent of these objects is to store quantile regression models with the exact same specifications aside from τ, but this pattern is not strictly enforced. The internal implementation may change in the future, however, so other uses are strongly discouraged.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Currently, a QuantRegModels object has a single field, models, which stores QuantRegModel objects in a dictionary indexed by their τ values. This dictionary should not be modified directly.","category":"page"},{"location":"types/#Constructor-1","page":"Types","title":"Constructor","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"This type has one constructor, which always creates an empty QuantRegModels object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModels","category":"page"},{"location":"types/#QuantReg.QuantRegModels","page":"Types","title":"QuantReg.QuantRegModels","text":"QuantRegModels()\n\nWrapper containing multiple QuantRegModel at different quantiles indexed by quantile. \n\nThis method implements some behaviors of a dictionary (for easy indexing) and some behaviors of an array (for easy, consistent appends). This type is not intended to be directly created by most end users.\n\nIf models::QuantRegModels contained models with τ=0.25, 0.5 and 0.75, these models could be accessed as models[0.25], models[0.5], and models[0.75] respectively.\n\n\n\n\n\n","category":"type"},{"location":"types/#Methods-2","page":"Types","title":"Methods","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"As a hybrid of an array and a dictionary, some methods intended for arrays and some intended for dictionaries are implemented for QuantRegModels.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"For example, to add a new model to a QuantRegModels object, one should use append!. This method ensures that the underlying dictionary exclusively contains QuantRegModel objects, that the models are indexed by their τ values, and that each QuantRegModels object contains no more than one QuantRegModel for a given τ value. ","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.append!(::QuantReg.QuantRegModels, ::QuantReg.QuantRegModel)","category":"page"},{"location":"types/#Base.append!-Tuple{QuantReg.QuantRegModels,QuantRegModel}","page":"Types","title":"Base.append!","text":"append!(X::QuantRegModels, model::QuantRegModel)\n\nAdd model to X in-place\n\nThrows an error if X already contains a model with the same τ value as model.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"A getindex method is implemented for this type so that users can access a particular model via the following syntax:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> models[τ]","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"where models is a QuantRegModels object and τ is a τ value for a QuantRegModel stored in models.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.getindex(::QuantReg.QuantRegModels, ::Number)","category":"page"},{"location":"types/#Base.getindex-Tuple{QuantReg.QuantRegModels,Number}","page":"Types","title":"Base.getindex","text":"getindex(X::QuantRegModels, τ::Number)\n\nReturns the model in X at the τth quantile.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"There are also two methods, taus and hastau, which respectively display all the τ values for which a QuantRegModels object contains a model and checks whther a given QuantRegModels object contains a model for a specific value of τ.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.taus\nQuantReg.hastau","category":"page"},{"location":"types/#QuantReg.taus","page":"Types","title":"QuantReg.taus","text":"taus(X::QuantRegModels)\n\nRetrive all the τ values for models stored in X.\n\n\n\n\n\n","category":"function"},{"location":"types/#QuantReg.hastau","page":"Types","title":"QuantReg.hastau","text":"getindex(X::QuantRegModels, τ::Number)\n\nCheck if X contains a model at the τth quantile.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"Types","title":"Types","text":"Lastly, there is also an implementation of show which nicely displays all the models stored in a QuantRegModels object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.show(::IO, ::QuantReg.QuantRegModels)","category":"page"},{"location":"types/#Base.show-Tuple{IO,QuantReg.QuantRegModels}","page":"Types","title":"Base.show","text":"show(io::IO, models:QuantRegModels)\n\nDisplay each model in models.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quickstart-Guide-1","page":"Quickstart","title":"Quickstart Guide","text":"","category":"section"},{"location":"quickstart/#Installation-1","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"QuantReg.jl is available via the Julia general repository. To use it on your machine, you will need to run the following commands:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> using Pkg\njulia> Pkg.add(QuantReg)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"The Gurobi.jl dependency package may fail to build if Gurobi is not installed on the machine; this is okay. QuantReg.jl can now be loaded in the REPL with the following command:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> using QuantReg","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Note that pre-compilation may take some time the first time the package is loaded; this is also to be expected.","category":"page"},{"location":"quickstart/#Running-your-first-model-1","page":"Quickstart","title":"Running your first model","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"The easiest way to generate, fit, and compute inference for a quantile regression model is via the rq command.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> using CSV, QuantReg\njulia> df = CSV.read(\"/path/to/data.csv\") # load dataset to fit\njulia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.50) # fit dataset","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"The resulting object model contains a median regression fitted and with inference computed according to default settings. For more information on default settings, see the QuantRegModel setting.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Within the result object, model.fit contains the results of fitting the model, including the coefficients, residuals, fitted values, and, for some fitting methods, the solution to the dual problem. For more information on how to access these values, see the QuantRegFit section.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"model.inf contains the results of computing inference for the model, which encompasses confidence interval bounds if a rank test inversion is used to compute inference and encompasses standard errors, test statistics, p-values, and confidence interval bounds if inference is computed using asymptotic estimates of the covariance matrix. For more information on how to access these values, see the QuantRegInf section.","category":"page"},{"location":"quickstart/#Running-models-at-multiple-quantiles-1","page":"Quickstart","title":"Running models at multiple quantiles","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"It is also possible to fit more than one model simultaneously by passing an array of τ  values. ","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> models = rq(@formula(Y ~ X1 + X2 + X3), df; τ=[0.25, 0.50, 0.75])","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"This call yields a QuantRegModels object containing three quantile regression models, fit at the 0.25th, 0.50th, and 0.75th quantiles. The individual models can be accessed by using the τ values as indices. For example,","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> models[0.25]","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"will return the quantile regression model fit at the 0.25th quantile. For more information on QuantRegModels objects, see the QuantRegModels section.","category":"page"},{"location":"quickstart/#Configuring-models-1","page":"Quickstart","title":"Configuring models","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Users can provide more detailed model specifications as keyword arguments to the quantile regression command. Any specification field in the QuantRegModel type can be accepted as a keyword argument. The following command fits a quantile regression model at the 0.80th quantile using the Frisch-Newton and computes 80% confidence intervals under the assumption that the conditional quantile function is locally (in tau) linear (in x) (i.e. regression errors are not i.i.d.).","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"rq","category":"page"},{"location":"quickstart/#QuantReg.rq","page":"Quickstart","title":"QuantReg.rq","text":"rq(formula::FormulaTerm, data::DataFrame; kwargs)\n\nGenerate, fit, and compute inference for a regression regression model according to the given specifications.\n\nAcceptable kwargs are the same as those accepted by QuantRegModel. To fit a model at multple quantiles, users can pass an array of quantiles values.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Under-the-hood-of-rq-1","page":"Quickstart","title":"Under the hood of rq","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"In code, the rq function is really a wrapper for three functions that constitute a common workflow. It first constructs a new QuantRegModel object according to the specifications provided. Then, it fits the model in place according to the specifications in the model with fit!. This function call updates the QuantRegFit object stored in the model. Finally, it computes inference for the model according to the specifications in the model with compute_inf!. This function call updates the QuantRegInf object stored in the model.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"For example, the call:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"is equivalent to:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> model = QuantRegModel(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, \n                             iid=false)\njulia> fit!(model)\njulia> compute_inf!(model)","category":"page"},{"location":"fitting/#Fitting-Quantile-Regression-Models-1","page":"Fitting models","title":"Fitting Quantile Regression Models","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.jl currently contains three methods for fitting quantile regression models: (1) the Barrodale-Roberts simple algorithm, (2) the Frisch-Newton algorithm, and (3) via the industrial solver Gurobi. The first two methods leverage FORTRAN code originally written for the R quantreg package. The third method was developed specifically for this package and only works if Gurobi is already installed on the user's machine.","category":"page"},{"location":"fitting/#Generic-functions-1","page":"Fitting models","title":"Generic functions","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"A QuantRegModel object, named model, can be fit using the generic fit!() function, and indeed, this is the function that most end users will leverage. This functions fits the object in place, modifying the QuantRegFit object stored at model.fit. For example,","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"julia> model = QuantRegModel(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\")","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"creates an unfitted a quantile regression model at the 0.80th quantile and specifies for it to be fit via the Frisch-Newton. Then,","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"julia> fit!(model)","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"fits the model in-place via the specified method.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Additionaly, there is a fit() method that creates a deep copy of the passed model, fits that copy, and returns the new, fitted model.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fit!(::QuantRegModel)\nQuantReg.fit","category":"page"},{"location":"fitting/#StatsBase.fit!-Tuple{QuantRegModel}","page":"Fitting models","title":"StatsBase.fit!","text":"fit!(model::QuantRegModel)\n\nFit model in-place according to model.fitmethod.\n\n\n\n\n\n","category":"method"},{"location":"fitting/#QuantReg.fit","page":"Fitting models","title":"QuantReg.fit","text":"fit(model::QuantRegModel)\n\nDeep copy model and fit according to model.fitmethod.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Ultimately, these two functions simply serve as a one-stop wrapper for fitting a model and calling different subroutines depending on the value of model.fitmethod.","category":"page"},{"location":"fitting/#Choosing-a-fitting-method-1","page":"Fitting models","title":"Choosing a fitting method","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Choosing the best fit method for a quantile regression model largely depends upon the size of the dataset that you are attempting to fit.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"For very small datasets (both in number of observations and number of predictors) the   Barrodale-Roberts simplex tended to outperform other fitting methods in limited   simulations. The speed difference between the Barrodale-Roberts simplex algorithm and   the Frisch-Newton algorithm, however, was negligible (both returned a model well within   one second), so either method seems like a good choice. Using Gurobi, however, imposes a   signficant speed penalty, mainly due to the fixed cost of initializing a Gurobi   environment. While the method still produces results relatively quickly (sub-two   seconds), this is substantially slower than the other algorithms.\nAs datasets grow in size, the Frisch-Newton algorithm and Gurobi catch-up to and   substantially overtake the Barrodale-Roberts simplex algorithm in speed. With the   exception of extremely large datasets, the Frisch-Newton algorithm still tends to   outperform the Gurobi algorithm due to the latter's fixed start-up costs. The speed of   the two methods is relatively similar in scale, however.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Going forward in development, the goal for the Gurobi solving method should be to produce a reusable Gurobi environment upon load to eliminate the fixed start-up costs.","category":"page"},{"location":"fitting/#Barrodale-Roberts-Simplex-Method-1","page":"Fitting models","title":"Barrodale-Roberts Simplex Method","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The Barrodale-Roberts simplex algorithm implemented can be used for both fitting a model and for computing inference via a rank test inversion. When fitting, the following method is called with the keyword argument, ci, set to its default value of false.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"br\" in either the rq function or the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitbr!","category":"page"},{"location":"fitting/#QuantReg.fitbr!","page":"Fitting models","title":"QuantReg.fitbr!","text":"fitbr!(model::QuantRegModel; ci::Bool=false),\n\nFit model using the Barrodale-Roberts method.\n\nIf ci is false, model.fit is updated in place to reflect the fit produced by running the Barrodale-Roberts simplex and confidence intervals are not computed. Otherwise, confidence intervals are computed, and model.inf is updated in place to reflect the confidence invervals produced by this method but model.fit is not updated.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"This method relies on a subroutine, fitbrfortran, that handles the FORTRAN call.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitbrfortran","category":"page"},{"location":"fitting/#QuantReg.fitbrfortran","page":"Fitting models","title":"QuantReg.fitbrfortran","text":"fitbrfortran(n::Integer, k::Integer, X::Matrix{Number}, y::Vector{Number},\n             τ::Number, nsol::Integer, ndsol::Integer, qn::Vector{Number},\n             cutoff::Number, lci1::Bool)\n\nWraps call to the public domain Barrodale-Roberts simplex FORTRAN routine.\n\nArguments\n\nn: number of observations\nk: number of parameters\nX: x matrix\ny: y vector\nτ: the desired quantile\nnsol: an estimated (row) dimension of the primal solution array\nndsol1: an estimated (row) dimension of the dual solution array\nqn: residuals variances from the projection of each column of X on remaining columns\ncutoff: the critical point for testing\nlci1: whether to calculate CI\n\n\n\n\n\n","category":"function"},{"location":"fitting/#Frisch-Newton-Algorithm-1","page":"Fitting models","title":"Frisch-Newton Algorithm","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The Frisch-Newton algorithm implemented is an interior point method that can be used to solve quantile regression problems. Unlike the other two methods in this package, this method does not produce solutions to the dual problem.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"fn\" in either the rq function or the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitfn!","category":"page"},{"location":"fitting/#QuantReg.fitfn!","page":"Fitting models","title":"QuantReg.fitfn!","text":"fitfn!(model::QuantRegModel)\n\nFit model using the Frish-Newton algorithm.\n\nFitting with this method does not produce solutions to the dual problem.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package. In the quantreg package, this is equivalent to the fn and fnb methods.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#Gurobi-1","page":"Fitting models","title":"Gurobi","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The only fitting method available via this package that is not available via the R quantreg package is fitting via Gurobi. This fitting method is only available to users who already have a licensed version of Gurobi installed on their machine and the Gurobi.jl package added in Julia. Even if an active Gurobi license is installed on the user's machine, the GUROBI_HOME environmental variable must be properly set for the Gurobi fitting method to be available.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"gurobi\" in either the rq function or the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitgurobi!","category":"page"},{"location":"fitting/#QuantReg.fitgurobi!","page":"Fitting models","title":"QuantReg.fitgurobi!","text":"fitgurobi(model::QuantRegModel)\n\nFit model using Gurobi via Julia's JuMP library.\n\nThis algorithm has been tailored specifically to work with Julia (hence the use of direct) mode. Some time was spent researching the use of open-source solvers such as GLPK, but they proved to be too slow. Extending this method to work with other solvers, such as CPLEX could be accomplished by switching the optimizer and creating the model in automatic mode, but this may leave some small efficiency gains on the table.\n\n\n\n\n\n","category":"function"},{"location":"#QuantReg.jl-Documentation-1","page":"Introduction","title":"QuantReg.jl Documentation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package provides types and functions for specifying, fitting, and computing inference for quantile regression models. This package was modeled after and employs FORTRAN libraries from the R package quantreg, authored by Roger Koenker.  Currently, the package implements many of the abstractions for statistical models from  StatsBase.jl and requires tabular data in the form of a DataFrame.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Contributions to this package that incorporate more features from the R quantreg package, add new features, or refine existing features are welcomed and encouraged on the project's GitHub. Please feel free to open an issue or pull request!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To install the package and get started, read the Quickstart Guide.","category":"page"},{"location":"inference/#Computing-Inference-for-Quantile-Regression-Models-1","page":"Inference","title":"Computing Inference for Quantile Regression Models","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.jl currently contains two primary methods for computing inference for a quantile regression model: (1) via a rank test inversion and (2) via an asymptotic estimate of the covariance matrix. The choice between these methods is determined by the invers flag in a QuantRegModel object:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"invers: if true, compute confidence intervals by inverting a rank test (only recommended   for datasets with <= 1000 observations); otherwise, use an asymptotic esimtate of the   covariance matrix","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Within each of these primary methods, there are a number of sub-options:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"α: size of the test for computing inference; be aware that this can affect results   beyond the confidence intervals if the Hall Sheather bandwidth is being used\nhs: if true, use the Hall Sheather bandwidth when computing sparsity esimtates (the   Hall Sheather bandwidth is always used for inference via rank test inversion)\niid:  if true, assume regression errors are iid; otherwise, assume that the conditional   quantile function is locally (in tau) linear (in x)\ninterpolate: if true, interpolate the confidence intervals produced by rank test   inversion inference; otherwise report values just above and just below each cutoff (only   applicable if inference is calculated via rank test inversion)\ntcrit: if true, use a Student's t distribution for calculating critical points;    otherwise use a standard normal distribution","category":"page"},{"location":"inference/#Generic-functions-1","page":"Inference","title":"Generic functions","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Much like the fit! and fit functions, inference for a QuantRegModel object can be computed using the generic compute_inf! and compute_inf functions. The compute_inf! function computes inference in place, modifying the QuantRegInf object stored at model.inf. The compute_inf() method creates a deep copy of the passed model, computes inference for the copied model, and returns the new model. For example:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, invers=true,\n          iid=false)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"creates an unfitted a quantile regression model at the 0.80th quantile and specifies for it to be fit via the Frisch-Newton. Inference is to be conducted via a rank test inversion under the assumpton that the conditional quantile function is locally (in tau) linear (in x) to produce 80% Confidence Intervals. Then:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> fit!(model)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"fits the model in place via the specified method. And finally:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> compute_inf!(model)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"computes inference in place as specified. Note that a model must be fit before inference can be computed.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_inf!\nQuantReg.compute_inf","category":"page"},{"location":"inference/#QuantReg.compute_inf!","page":"Inference","title":"QuantReg.compute_inf!","text":"compute_inf!(model)\n\nIn-place version of compute_inf!.\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.compute_inf","page":"Inference","title":"QuantReg.compute_inf","text":"compute_inf(model::QuantRegModel)\n\nCompute inference for model as specified in that object.\n\n\n\n\n\n","category":"function"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Ultimately, these two functions simply serve as a one-stop wrappers for computing inference and call different subroutines depending on the specifications of the model.","category":"page"},{"location":"inference/#Rank-Test-Inversion-1","page":"Inference","title":"Rank Test Inversion","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"To compute confidence intervals by inverting a rank test, this algorithm leverages the same function and FORTRAN routine for fitting a model with the Barrodale-Roberts simplex  algorithm. In this case, however, the keyword argument, ci is set to true. One can see the documentation for this function in the Barrodale-Roberts Simplex Method section  of the Fitting Quantile Regression Models section.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"There are three subroutines for fitbr! specific to computing inference via rank test inversion. End users should not need to call these directly, but they are included here for completeness.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_nid_qn_invers\nQuantReg.init_ci_invers\nQuantReg.write_ci!","category":"page"},{"location":"inference/#QuantReg.compute_nid_qn_invers","page":"Inference","title":"QuantReg.compute_nid_qn_invers","text":"compute_nid_qn_invers(i::Integer, data::DataFrame, regressors::Array{<:AbstractTerm},\n                      weights::Array{<:Number})\n\nComputes residuals variances from the projection of each column of X on remaining columns for rank test inversion inference under the n.i.d. assumption.\n\nThis function should be of little interest to end users as it is primarily a helper function for computing inference with a rank test inversion and with n.i.d. errors.\n\nArguments\n\ni: enumeration of column to project\ndata: data used to fit the model\nregressors: list of regressors from the model\nweights: weight to use in calculating projection as a linear regression\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.init_ci_invers","page":"Inference","title":"QuantReg.init_ci_invers","text":"init_inf_invers(model::QuantRegModel)\n\nInitialize necessary values for calculating confidence intervals for model via rank test inversion. \n\nThis function should be of little interest to end users as it is solely used as a subroutine when calling fitbr(model; ci=true).\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.write_ci!","page":"Inference","title":"QuantReg.write_ci!","text":"write_ci(model::QuantRegModel, ci::Array{Number, 2})\n\nWrite ranks test inversion confidence intervals to model.inf.\n\nci should be a set of  confidence interval matrix produced by a call to fitbr(model; ci=true).\n\n\n\n\n\n","category":"function"},{"location":"inference/#Asymptotic-Estimate-of-Covariance-Matrix-1","page":"Inference","title":"Asymptotic Estimate of Covariance Matrix","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"The package can compute inference via an asymptotic estimate of the covariance matrix. All code for this method is written directly in Julia using one of two functions, compute_σ_iid_asy  if regression errors are assumed to be iid and compute_σ_nid_asy otherwise. These functions are closely modeled on analogous code in the R quantreg pakage.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_σ_iid_asy\nQuantReg.compute_σ_nid_asy","category":"page"},{"location":"inference/#QuantReg.compute_σ_iid_asy","page":"Inference","title":"QuantReg.compute_σ_iid_asy","text":"compute_σ_iid_asy(model::QuantRegModel)\n\nCompute standard errors for model using an estimate of the asymptotic covariance matrix under the assumtion that errors are iid.\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.compute_σ_nid_asy","page":"Inference","title":"QuantReg.compute_σ_nid_asy","text":"compute_σ_nid_asy(model::QuantRegModel)\n\nCompute standard errors for model using an estimate of the asymptotic covariance matrix under the assumption that the conditional quantile function is locally (in tau) linear (in x).  \n\n\n\n\n\n","category":"function"},{"location":"inference/#Generic-Subroutines-1","page":"Inference","title":"Generic Subroutines","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"In addition, there is a subroutine, compute_bandwidth that is used to calculate the τ bandwidth for sparsity estimation in both primary methods for calculating inference.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_bandwidth","category":"page"},{"location":"inference/#QuantReg.compute_bandwidth","page":"Inference","title":"QuantReg.compute_bandwidth","text":"calcbandwidth(τ::Number, n::Integer, α::Number; hs=false)\n\nCalculate the τ bandwidth for sparsity estimation when calculating inference under the assumption that the conditional quantile function is locally (in tau) linear (in x).  \n\nArguments\n\nτ: quantile\nn: sample size\nα: alpha level for intended confidence interval\nhs: if true, use Hall Sheather bandwidth; otherwise, use Bofinger bandwidth\n\n\n\n\n\n","category":"function"},{"location":"example/#Example-1","page":"Example usage","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"To further explore the use of this package, consider the following short example. We use a 9,800 observation subset of the 1996 US natality dataset used in Abrevaya (2006).","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"To load this dataset and run quantile regressions, we first load in the CSV.jl and  QuantReg.jl packages then import the dataset from file:","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> using CSV, QuantReg\n[ Info: Precompiling QuantReg [a0becc08-653f-40d2-91e7-721373d1053f]\n\njulia> df = CSV.read(\"./bwght.csv\")\n9800×14 DataFrames.DataFrame\n│ Row  │ birthweight │ boy   │ married │ black │ age   │ highschool │ somecollege │ college │\n│      │ Int64       │ Int64 │ Int64   │ Int64 │ Int64 │ Int64      │ Int64       │ Int64   │ \n├──────┼─────────────┼───────┼─────────┼───────┼───────┼────────────┼─────────────┼─────────┼─\n│ 1    │ 2926        │ 0     │ 1       │ 0     │ 25    │ 1          │ 0           │ 0       │ \n│ 2    │ 3595        │ 0     │ 0       │ 1     │ 17    │ 0          │ 0           │ 0       │ \n│ 9798 │ 3325        │ 1     │ 1       │ 1     │ 26    │ 1          │ 0           │ 0       │ \n│ 9799 │ 3232        │ 1     │ 0       │ 1     │ 21    │ 0          │ 1           │ 0       │ \n│ 9800 │ 2495        │ 0     │ 0       │ 0     │ 18    │ 0          │ 0           │ 0       │ \n\n│ prenone │ presecond │ prethird │ smoker │ cigsdaily │ weightgain │\n│ Int64   │ Int64     │ Int64    │ Int64  │ Int64     │ Int64      │\n│ ────────┼───────────┼──────────┼────────┼───────────┼────────────┤\n│ 0       │ 0         │ 0        │ 0      │ 3         │ 22         │\n│ 0       │ 0         │ 0        │ 1      │ 0         │ 44         │\n│ 0       │ 0         │ 0        │ 1      │ 0         │ 99         │\n│ 0       │ 0         │ 0        │ 1      │ 0         │ 40         │\n│ 0       │ 0         │ 0        │ 0      │ 2         │ 25         │","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Using the rq function, we the fit three quantile regression models at the 0.25th, 0.50th, and 0.75th quantiles. We specify for the models be fit using the Barrodale-Roberts simplex algorithm but otherwise allow the program to choose sensible defaults (see QuantRegModel).","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> models = rq(@formula(birthweight ~ boy + married + black + age + highschool +\n                            somecollege + college + prenone + presecond + prethird + smoker\n                            + cigsdaily + weightgain), df, τ=[0.25:0.25:0.75;],\n                   fitmethod=\"br\")\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone\n+ presecond + prethird + smoker + cigsdaily + weightgain, τ=0.25\n───────────────────────────────────────────────────────────────────────────────────────────\n             Coefficient  Std. Error           t      P(>|t|)   95% CI Lower   95% CI Upper\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)  2649.39       51.4538     51.4905    0.0             2548.53        2750.25\nboy            95.6971     14.2654      6.70834   2.07738e-11       67.734        123.66\nmarried        29.5964     19.5786      1.51167   0.13065           -8.78172       67.9746\nblack        -237.98       18.8469    -12.627     0.0             -274.923       -201.036\nage            -0.927394    1.54661    -0.599631  0.548766          -3.95906        2.10428\nhighschool     92.5733     20.0475      4.6177    3.92964e-6        53.2761       131.87\nsomecollege   128.694      23.1254      5.56505   2.68988e-8        83.3634       174.025\ncollege       102.463      28.3025      3.62028   0.000295771       46.9842       157.941\nprenone      -157.604     171.45       -0.919242  0.357992        -493.681        178.473\npresecond      -9.87082    21.7078     -0.454712  0.649326         -52.4227        32.681\nprethird       15.253      32.98        0.462493  0.643738         -49.3946        79.9006\nsmoker        230.066      37.497       6.13558   8.8137e-10       156.564        303.568\ncigsdaily      -2.19568     2.19156    -1.00188   0.316426          -6.49159        2.10023\nweightgain      2.63786     0.322655    8.17549   4.44089e-16        2.00539        3.27033\n───────────────────────────────────────────────────────────────────────────────────────────\n\nDegrees of freedom: 9800 total; 9786 residual\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone\n+ presecond + prethird + smoker + cigsdaily + weightgain, τ=0.5\n───────────────────────────────────────────────────────────────────────────────────────────\n             Coefficient  Std. Error           t      P(>|t|)   95% CI Lower   95% CI Upper\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)   2845.8       47.0243     60.5175    0.0             2753.62        2937.97\nboy            121.298     12.2698      9.88595   0.0               97.247        145.35\nmarried         14.1307    17.4178      0.81128   0.417225         -20.0117        48.2731\nblack         -227.1       15.9263    -14.2594    0.0             -258.319       -195.882\nage              4.79392    1.34459     3.56535   0.000365106        2.15825        7.42959\nhighschool      62.8769    17.9189      3.50897   0.000451868       27.7521        98.0016\nsomecollege     95.2196    20.0219      4.75577   2.00515e-6        55.9725       134.467\ncollege         76.7584    24.0546      3.191     0.00142229        29.6063       123.91\nprenone        -87.0081    75.4319     -1.15346   0.248748        -234.87          60.8541\npresecond       31.7744    19.3375      1.64315   0.100384          -6.13109       69.6799\nprethird        17.4735    42.536       0.410792  0.681234         -65.9059       100.853\nsmoker         230.295     34.8011      6.61748   3.84524e-11      162.078        298.513\ncigsdaily       -2.19744    2.04107    -1.07661   0.28168           -6.19837        1.80348\nweightgain       2.83568    0.374805    7.56575   4.21885e-14        2.10099        3.57038\n───────────────────────────────────────────────────────────────────────────────────────────\n\nDegrees of freedom: 9800 total; 9786 residual\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone\n+ presecond + prethird + smoker + cigsdaily + weightgain, τ=0.75\n───────────────────────────────────────────────────────────────────────────────────────────\n             Coefficient  Std. Error           t      P(>|t|)   95% CI Lower   95% CI Upper\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)   3170.49      47.8338     66.2814    0.0            3076.73         3264.26\nboy            126.695     13.553       9.34808   0.0             100.128         153.262\nmarried          7.32203   18.7681      0.390132  0.696448        -29.4673         44.1114\nblack         -208.254     18.1268    -11.4887    0.0            -243.787        -172.722\nage              6.28814    1.44357     4.35595   1.3384e-5         3.45843         9.11784\nhighschool      36.4407    19.0143      1.91649   0.0553318        -0.831229       73.7126\nsomecollege     76.7797    22.2705      3.4476    0.000567972      33.1249        120.434\ncollege         53.1864    25.0569      2.12263   0.0338101         4.06978       102.303\nprenone       -161.627     44.68       -3.61744   0.00029903     -249.209         -74.0451\npresecond       46.6102    20.2305      2.30396   0.0212458         6.95427        86.2661\nprethird        -6.30508   35.184      -0.179203  0.857782        -75.2731         62.6629\nsmoker         154.847     34.4751      4.49158   7.1507e-6        87.2692        222.426\ncigsdaily       -5.60339    1.78481    -3.13949   0.00169747       -9.10199        -2.10479\nweightgain       3.98305    0.355627   11.2001    0.0               3.28595         4.68015\n───────────────────────────────────────────────────────────────────────────────────────────\n\nDegrees of freedom: 9800 total; 9786 residual","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Above, we can see the results of the three models printed to the console. These results plus deeper information about each of the models is also stored in the models object. We can directly access each of the models by indexing the models object by τ values. For example, to access the median regression object, we would do the following:","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> models[0.5]\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone +\npresecond + prethird + smoker + cigsdaily + weightgain, τ=0.5\n───────────────────────────────────────────────────────────────────────────────────────────\n             Coefficient  Std. Error           t      P(>|t|)   95% CI Lower   95% CI Upper\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)   2845.8       47.0243     60.5175    0.0             2753.62        2937.97\nboy            121.298     12.2698      9.88595   0.0               97.247        145.35\nmarried         14.1307    17.4178      0.81128   0.417225         -20.0117        48.2731\nblack         -227.1       15.9263    -14.2594    0.0             -258.319       -195.882\nage              4.79392    1.34459     3.56535   0.000365106        2.15825        7.42959\nhighschool      62.8769    17.9189      3.50897   0.000451868       27.7521        98.0016\nsomecollege     95.2196    20.0219      4.75577   2.00515e-6        55.9725       134.467\ncollege         76.7584    24.0546      3.191     0.00142229        29.6063       123.91\nprenone        -87.0081    75.4319     -1.15346   0.248748        -234.87          60.8541\npresecond       31.7744    19.3375      1.64315   0.100384          -6.13109       69.6799\nprethird        17.4735    42.536       0.410792  0.681234         -65.9059       100.853\nsmoker         230.295     34.8011      6.61748   3.84524e-11      162.078        298.513\ncigsdaily       -2.19744    2.04107    -1.07661   0.28168           -6.19837        1.80348\nweightgain       2.83568    0.374805    7.56575   4.21885e-14        2.10099        3.57038\n───────────────────────────────────────────────────────────────────────────────────────────\n\nDegrees of freedom: 9800 total; 9786 residual","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Say we wanted to make some change to the model from above. We could do so directly from this model by using the provided QuantRegModel convenience constructor. In the following code block, we generate a new model where regression errors are assumed to be iid from the existing model at the 0.50th quantile.","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> altmodel = QuantReg.QuantRegModel(models[0.5], iid=true)\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone\n+ presecond + prethird + smoker + cigsdaily + weightgain, τ=0.5\n────────────────────────\n             Coefficient\n────────────────────────\n(Intercept)   2845.8\nboy            121.298\nmarried         14.1307\nblack         -227.1\nage              4.79392\nhighschool      62.8769\nsomecollege     95.2196\ncollege         76.7584\nprenone        -87.0081\npresecond       31.7744\nprethird        17.4735\nsmoker         230.295\ncigsdaily       -2.19744\nweightgain       2.83568\n────────────────────────","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Notice that this model, stored in altmodel still has its fit but does not have inference computed; this is because changing the assumption about the distribution of the regression errors only affects computing inference. To compute inference for altmodel, we run the following command:","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> QuantReg.compute_inf!(altmodel)\n\nbirthweight ~ 1 + boy + married + black + age + highschool + somecollege + college + prenone\n+ presecond + prethird + smoker + cigsdaily + weightgain, τ=0.5\n───────────────────────────────────────────────────────────────────────────────────────────\n             Coefficient  Std. Error           t      P(>|t|)   95% CI Lower   95% CI Upper\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)   2845.8        45.6468    62.3438    0.0             2756.32        2935.27\nboy            121.298      12.5634     9.65487   0.0               96.6714       145.925\nmarried         14.1307     17.352      0.814353  0.415463         -19.8829        48.1443\nblack         -227.1        16.2947   -13.9371    0.0             -259.041       -195.159\nage              4.79392     1.29373    3.70551   0.000212125        2.25795        7.3299\nhighschool      62.8769     17.5895     3.57469   0.000352329       28.3979        97.3558\nsomecollege     95.2196     20.4008     4.66744   3.09033e-6        55.2297       135.209\ncollege         76.7584     24.1841     3.17392   0.00150859        29.3526       124.164\nprenone        -87.0081     58.4498    -1.4886    0.136626        -201.582         27.5656\npresecond       31.7744     18.4814     1.71926   0.0855979         -4.45295       68.0018\nprethird        17.4735     39.3888     0.443615  0.657331         -59.7368        94.6837\nsmoker         230.295      33.8347     6.80649   1.05878e-11      163.972        296.618\ncigsdaily       -2.19744     2.19289   -1.00208   0.316332          -6.49596        2.10108\nweightgain       2.83568     0.30841    9.19452   0.0                2.23114        3.44023\n───────────────────────────────────────────────────────────────────────────────────────────\n\nDegrees of freedom: 9800 total; 9786 residual","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Returning to the original model fit at the 0.50th quantile, we can also access information about its fit and inference directly. Since we fit via the Barrodale-Roberts simplex algorithm, the program computes and stores the dual solution to the quantile regression linear program. We can access that solution as follows:","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> models[0.5].fit.dual\n9800-element Array{Float64,1}:\n 0.0\n 1.0\n 1.0\n 0.0\n 0.0\n ⋮\n 1.0\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"There are a number of other values that can be accessed via the fields of the QuantRegFit object stored at models[0.5].fit. For a full list, see the QuantRegFit section.","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"Similarly, we could access the column vector of standard errors seen above as follows:","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"julia> models[0.5].inf.σ\n14-element Array{Float64,1}:\n 47.02433161327634\n 12.26976221196334\n 17.417768956074895\n 15.92630617837017\n  1.3445878800214834\n  ⋮\n 19.3375090921255\n 42.53601653109182\n 34.801095529285575\n  2.0410717521211215\n  0.3748053760950519","category":"page"},{"location":"example/#","page":"Example usage","title":"Example usage","text":"There are also a number of other values that can be accessed via the fields of the QuantRegInf object stored at models[0.5].inf. For a full list, see the QuantRegInf section.","category":"page"}]
}

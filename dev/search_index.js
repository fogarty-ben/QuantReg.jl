var documenterSearchIndex = {"docs":
[{"location":"#","page":"-","title":"-","text":"Modules = [QuantReg]\nOrder   = [:function, :type]","category":"page"},{"location":"#QuantReg.compute_inf!-Tuple{QuantRegModel}","page":"-","title":"QuantReg.compute_inf!","text":"compute_inf!(model)\n\nIn-place version of [compute_inf!(model)]\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.compute_inf-Tuple{QuantRegModel}","page":"-","title":"QuantReg.compute_inf","text":"compute_inf(model::QuantRegModel)\n\nCompute inference for model as specified in model.inf.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.rq-Tuple{StatsModels.FormulaTerm,DataFrames.DataFrame}","page":"-","title":"QuantReg.rq","text":"rq(formula::FormulaTerm, data::DataFrame; kargs)\n\nGenerate, fit, and compute inference for the specified quantile regression model.\n\nKeyword Arguments\n\n\n\n\n\n","category":"method"},{"location":"#StatsBase.coeftable-Tuple{QuantRegModel}","page":"-","title":"StatsBase.coeftable","text":"coeftable(model::QuantRegModel)\n\nGenerate a coefficient table from a QuantRegModel.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.QuantRegModel","page":"-","title":"QuantReg.QuantRegModel","text":"QuantRegModel(formula::FormulaTerm, data::DataFrame; τ::Number=0.5,\n              fitmethod::String=\"br\",invers::Union{Nothing, Bool}=nothing,\n              α::Number=0.05, hs::Bool=true, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Bool=true, tcrit::Bool=true)\n\nQuantile Regression model at the τth quantile fitting data according to formula.\n\nIn any call, formula and data must be set. Additional parameters and their defaults are as specified below:\n\nτ: the quantile to fit the model at; default is 0.5, i.e. median regression\nfitmethod: the method to fit the model with; avaliable options are:\n\"br\": fit using Barrodlae-Roberts simplex (default method); see [fitbr!] for \ndetails\n\"fn\": Fit using Frisch-Newton algorithm; see [fitfn!`] for details\n\"gurobi\": Fit using Gurobi (must have Gurobi installed); see [fitgurobi!``]\ninvers: if true, compute confidence intervals by inverting a rank test (otherwise use an\n\nasymptotic esimtate of the covariance matrix); default setting is datasets with 1000 or fewer observations and false for larger datasets\n\nα: size of test for computing inference; default setting is 0.05\nhs: if true, use Hall Sheather bandwidth when computing sparsity esimtates\n\n(otherwise, use Bofinger bandwidth); default is true\n\niid: if true, assume model errors are iid (otherwise, assume that the conditional\n\nquantile function is locally (in tau) linear (in x)); default is true if using rank test inversion and false if using an asymptotic estimate of the covariance matrix\n\ninterpolate: if true, interpolate the confidence intervals produced by rank test\n\ninversion inference (otherwise, print values just above and below); default is true\n\ntcrit: if true, use a Student's t distribution for calculating critical points\n\n(otherwise use a normal distribution); default is true\n\n\n\n\n\n","category":"type"},{"location":"#QuantReg.QuantRegModel-Tuple{QuantRegModel}","page":"-","title":"QuantReg.QuantRegModel","text":"QuantRegModel(model::QuantRegModel; τ::Union{Nothing, Number}=nothing,\n              fitmethod::Union{Nothing, String}=nothing,\n              invers::Union{Nothing, Bool}=nothing, α::Union{Nothing, Number}=nothing,\n              hs::Union{Nothing, Bool}=nothing, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Union{Nothing, Bool}=nothing,\n              tcrit::Union{Nothing, Bool}=nothing)\n\nConstruct a new QuantileRegression model by changing a parameter in an existing model.\n\nIf τ or method are unchanged, then the model fit is retained from the passed model but the model inference type is not.\n\n\n\n\n\n","category":"method"},{"location":"#Base.append!-Tuple{QuantReg.QuantRegModels,QuantRegModel}","page":"-","title":"Base.append!","text":"append!(X::QuantRegModels, model::QuantRegModel)\n\nAdd model to X in-place; throws an error if X already contains a model with the same τ value as model.\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{QuantReg.QuantRegFit}","page":"-","title":"Base.copy","text":"copy(fit::QuantRegFit)\n\nCreate a deep copy of fit.\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{QuantReg.QuantRegInf}","page":"-","title":"Base.copy","text":"copy(inf::QuantRegInf)\n\nCreate a deep copy of inf.\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{QuantRegModel}","page":"-","title":"Base.copy","text":"copy(model::QuantRegModel)\n\nCreate a deep copy of model (excluding data and formula).\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{QuantReg.QuantRegModels,Number}","page":"-","title":"Base.getindex","text":"getindex(X::QuantRegModels, τ::Number)\n\nReturns the model in X fit at the τth quantile.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO,QuantReg.QuantRegModels}","page":"-","title":"Base.show","text":"show(io::IO, models:QuantRegModels)\n\nDisplay each model in models.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO,QuantRegModel}","page":"-","title":"Base.show","text":"show(io::IO, model:QuantRegModel)\n\nDisplay quantreg model.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.compute_bandwidth-Tuple{Any,Any,Any}","page":"-","title":"QuantReg.compute_bandwidth","text":"calcbandwidth(τ::Number, n::Integer, α::Number; hs=false)\n\nCalculate the τ bandwidth for sparsity estimation when calculating inference under the assumption that the conditional quantile function is locally (in tau) linear (in x).  \n\nArguments\n\nτ: quantile\nn: sample size\nα: alpha level for intended confidence interval\nhs: if true, use Hall Sheather bandwidth; otherwise, use Bofinger bandwidth\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.compute_nid_qn_invers-Tuple{Integer,DataFrames.DataFrame,Array{#s36,N} where N where #s36<:StatsModels.AbstractTerm,Array{#s35,1} where #s35<:Number}","page":"-","title":"QuantReg.compute_nid_qn_invers","text":"compute_nid_qn_invers(i::Integer, data::DataFrame, regressors::Array{<:AbstractTerm},\n                  weights::Array{<:Number})\n\nComputes residuals variances from the projection of each column of X on remaining columns for rank test inversion inference under the n.i.d. assumption.\n\nThis function should be of little interest to end users as it is primarily a helper function for computing inference with a rank test inversion and with n.i.d. errors.\n\nArguments\n\ni: enumeration of column to project\ndata: data used to fit the model\nregressors: list of regressors from the model\nweights: weight to use in calculating projection as a linear regression\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.compute_σ_iid_asy-Tuple{QuantRegModel}","page":"-","title":"QuantReg.compute_σ_iid_asy","text":"compute_σ_iid_asy(model::QuantRegModel)\n\nCompute standard errors for a model using an estimate of the asymptotic covariance matrix under the assumtion that errors are iid.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.compute_σ_nid_asy-Tuple{QuantRegModel}","page":"-","title":"QuantReg.compute_σ_nid_asy","text":"compute_σ_nid_asy(model::QuantRegModel)\n\nCompute standard errors for a model using an estimate of the asymptotic covariance matrix under the assumption that the conditional quantile function is locally (in tau) linear (in x).  \n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.fit-Tuple{QuantRegModel}","page":"-","title":"QuantReg.fit","text":"fit(model::QuantRegModel)\n\nFit model according to model.fit.method.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.fitbr!-Tuple{QuantRegModel}","page":"-","title":"QuantReg.fitbr!","text":"fitbr!(model::QuantRegModel; ci::Bool=false),\n\nFit model using the Barrodale-Roberts method.\n\nIf ci is false, model.fit is updated in place to reflect the fit produced by running the Barrodale-Roberts simplex, and confidence intervals are not computed. Otherwise, confidence intervals are computed, and model.inf is updated in place to reflect the confidence invervals produced by this method, but model.fit is not updated.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.fitbrfortran-Tuple{Integer,Integer,Array{#s35,2} where #s35<:Number,Array{#s34,1} where #s34<:Number,Number,Integer,Integer,Array{#s33,1} where #s33<:Number,Number,Bool}","page":"-","title":"QuantReg.fitbrfortran","text":"fitbrfortran(n::Integer, k::Integer, X::Matrix{Number}, y::Vector{Number},\n             τ::Number, nsol::Integer, ndsol::Integer, qn::Vector{Number},\n             cutoff::Number, lci1::Bool)\n\nWraps call to the public domain Barrodale-Roberts simplex FORTRAN routine.\n\nArguments\n\nn: number of observations\nk: number of parameters\nX: x matrix\ny: y vector\nτ: the desired quantile\nnsol: an estimated (row) dimension of the primal solution array\nndsol1: an estimated (row) dimension of the dual solution array\nqn: residuals variances from the projection of each column of X on remaining columns\ncutoff: the critical point for testing\nlci1: whether to calculate CI\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.fitfn!-Tuple{QuantRegModel}","page":"-","title":"QuantReg.fitfn!","text":"fitfn(model::QuantRegModel)\n\nFit model using the Frish-Newton algorithm.\n\nFitting with this method does not produce solutions to the dual problem.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package. In the quantreg packaage, this is equivalent to the fn and fnb methods.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.fitgurobi!-Tuple{QuantRegModel}","page":"-","title":"QuantReg.fitgurobi!","text":"fitgurobi(model::QuantRegModel)\n\nFit model using Gurobi via Julia's JuMP library.\n\nThis algorithm has been tailored specifically to work with Julia (hence the use of direct) mode. Some time was spent researching the use of open-source solvers such as GLPK, but they proved to be too slow. Extending this method to work with other solvers, such as CPLEX could be accomplished by switching the optimizer and creating the model in automatic mode, but this may leave some small efficiency gains on the table.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.hastau-Tuple{QuantReg.QuantRegModels,Number}","page":"-","title":"QuantReg.hastau","text":"getindex(X::QuantRegModels, τ::Number)\n\nCheck if X contains a model at the τth percentile.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.init_ci_invers-Tuple{QuantRegModel}","page":"-","title":"QuantReg.init_ci_invers","text":"init_inf_invers(model::QuantRegModel)\n\nInitialize necessary values for calculating confidence intervals for model with a rank test inversion. \n\nThis function should be of little interest to end users as it is solely used as a subroutine when calling [fitbr(model; ci=true)].\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.taus-Tuple{QuantReg.QuantRegModels}","page":"-","title":"QuantReg.taus","text":"taus(X::QuantRegModels)\n\nRetrive all the τ values for models stored in X.\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.write_ci!-Tuple{QuantRegModel,Array{Float64,2},Array{Float64,2},Float64}","page":"-","title":"QuantReg.write_ci!","text":"write_ci(model::QuantRegModel, ci::Array{Number, 2})\n\nWrite confidence intervals to model.inf.\n\nci should be a set of  confidence interval matrix produced by a call to [fitbr(model; ci=true)].\n\n\n\n\n\n","category":"method"},{"location":"#StatsBase.fit!-Tuple{QuantRegModel}","page":"-","title":"StatsBase.fit!","text":"fit!(model::QuantRegModel)\n\nIn-place version of [fit(model)].\n\n\n\n\n\n","category":"method"},{"location":"#QuantReg.QuantRegFit","page":"-","title":"QuantReg.QuantRegFit","text":"QuantRegFit(computed::Bool, coef::Union{Vector, Nothing}, resid::Union{Vector, Nothing},\n            dual::Union{Array, Nothing}, yhat::Union{Vector, Nothing})\n\nStores results of fitting a quantile regression model.\n\ncoef, resid, dual, and yhat should be set to nothing until a model is fit.\n\n\n\n\n\n","category":"type"},{"location":"#QuantReg.QuantRegInf","page":"-","title":"QuantReg.QuantRegInf","text":"QuantRegInf(computed::Bool, lowerci::Union{Nothing, Array{Number}},\n            upperci::Union{Nothing, Array{Number}}, σ::Union{Nothing, Array{Number}},\n            teststat::Union{Nothing, Array{Number}}, p::Union{Nothing, Array{Number}})\n\nContains specifcations for and results of computing inference for a quantile regression model.\n\nlowerci, upperci, σ, teststat should be set to nothing until inference is computed.\n\n\n\n\n\n","category":"type"},{"location":"#QuantReg.QuantRegModels","page":"-","title":"QuantReg.QuantRegModels","text":"QuantRegModels()\n\nWrapper containing multiple QuantRegModel at different quantiles indexed by quantile. \n\nThis method partically implements some behaviors of a dictionary (for easy indexing) and some behaviors of an array (for easy, consistent appends). This type is not intended to be directly created by most end users.\n\nFor example, if a models::QuantRegModels contained models with τ=0.25, 0.5 and 0.75, these models could be accessed as models[0.25], models[0.5], and models[0.75] respectively.\n\n\n\n\n\n","category":"type"}]
}

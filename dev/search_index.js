var documenterSearchIndex = {"docs":
[{"location":"types/#QuantReg.jl-Types-1","page":"Types","title":"QuantReg.jl Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"The QuantReg.jl package introduces four types: QuantRegFit, QuantRegInf, QuantRegModel, and QuantRegModels. For most users, a deep understanding of these types is unnecessary, but the structure of these types will be helpful for advanced users, students investigating the properties of quantile regression, or developers wishing to extend the package.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"These four types work together as follows. A QuantRegModel is an immutable object and contains all of the specification necessary to fit and compute inference for a model plus a QuantRegFit object and a QuantRegInf object that respectively store the results of fitting the model and computing inference. A QuantRegModel object stores multiple  QuantRegModel objects, indexed by their τ values; note that a QuantRegModels object cannot contain multple QuantRegModel objects with the same τ value.","category":"page"},{"location":"types/#QuantRegFit-1","page":"Types","title":"QuantRegFit","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegFit objects store the results of fitting a quantile regression model and are mutable. Each instance contains the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"computed: denotes whether or not the parent model has been fit\ncoef: stores the coefficients for a fitted model or nothing if   model hasn't been fit\nresid: stores the residuals for each observation or nothing if   the model hasn't been fit\ndual: stores the solution to the dual problem if the fitting   method produces the dual solution or nothing if the model hasn't been fit or the fitting   method does not produce the dual solution\nyhat: stores the fitted values for the dataset used to build the   model or nothing if the model hasn't been fit","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegFit has one construtor, the default constructor in which all field values are specified directly. QuantRegFit objects are primarily constructed in the creation of QuantRegModel objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegFit","category":"page"},{"location":"types/#QuantReg.QuantRegFit","page":"Types","title":"QuantReg.QuantRegFit","text":"QuantReg.QuantRegFit(computed::Bool, coef::Union{Vector{<:Number}, Nothing},\n                     resid::Union{Vector{<:Number}, Nothing}, \n                     dual::Union{Vector{<:Number}, Nothing},\n                     yhat::Union{Vector{<:Number}, Nothing})\n\nStores results of fitting a quantile regression model.\n\ncoef, resid, dual, and yhat should be set to nothing until a model is fit.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, there is a method to create deep copies of QuantRegFit objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegFit)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantReg.QuantRegFit}","page":"Types","title":"Base.deepcopy","text":"deepcopy(fit::QuantRegFit)\n\nCreate a deep copy of fit.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegInf-1","page":"Types","title":"QuantRegInf","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"Similarly, QuantRegInf objects store the results of computing inference for a quantile regression model and are mutable. Each instance contains the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"computed: denotes whether or not inference has been computed for the parent model\nlowerci: lower bounds for the specified confidence intervals or nothing if inference   hasn't been computed for the model; a (k x 1) matrix unless inference is computed via    rank test inversion and interpolate is set to false in which case, a (k x 2) matrix\nupperci: upper bounds for the specified confidence intervals or nothing if the inference   hasn't been computed for the model; a (k x 1) matrix unless inference is computed via   rank test inversion and interpolate is set to false in which case, a (k x 2) matrix\nσ: standard errors for the coefficients or nothing if the inference hasn't been computed   for the model or is calculated via a rank test inversion\nteststat: t or z statistics for the coefficients or nothing if inference hasn't been   computed for the model or is calculated via a rank test inversion\np: p values for the coefficients or nothing if inference hasn't been computed for the   model or is calculated via a rank test inversion","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegInf also has one construtor, the default constructor in which all field values are specified directly. QuantRegFit objects are primarily constructed in the creation of QuantRegModel objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegInf","category":"page"},{"location":"types/#QuantReg.QuantRegInf","page":"Types","title":"QuantReg.QuantRegInf","text":"QuantReg.QuantRegInf(computed::Bool,\n                     lowerci::Union{Nothing, Vector{<:Number}, Matrix{<:Number}}\n                     upperci::Union{Nothing, Vector{<:Number}, Matrix{<:Number}}\n                     σ::Union{Nothing, Vector{<:Number}}\n                     teststat::Union{Nothing, Vector{<:Number}}\n                     p::Union{Nothing, Vector{<:Number}})\n\nStores results of computing inference for a quantile regression model.\n\nlowerci, upperci, σ, teststat should be set to nothing until inference is computed.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, there is a method to create deep copies of QuantRegInf objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegInf)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantReg.QuantRegInf}","page":"Types","title":"Base.deepcopy","text":"deepcopy(inf::QuantRegInf)\n\nCreate a deep copy of inf.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegModel-1","page":"Types","title":"QuantRegModel","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantRegModel is the type with which end users are most likely to interact. QuantRegModel objects are immutable and contain the following fields:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"formula: the formula to fit the data\ndata: DataFrame object containing data to fit the model with\nmf: ModelFrame object created by apply formula to data\nmm: ModelMatrix object created from mf\nτ: quantile to fit the model at\nfitmethod: the algorithm/method to fit the model; available options are:\n\"br\": fit using Barrodale-Roberts simplex (default method); see [fitbr!] for \ndetails\n\"fn\": Fit using Frisch-Newton algorithm; see [fitfn!] for details\n\"gurobi\": Fit using Gurobi (must have Gurobi installed); see [fitgurobi!`]\ninvers: if true, compute confidence intervals by inverting a rank test (only recommended   for datasets with <= 1000 observations); otherwise, use an asymptotic esimtate of the   covariance matrix\nα: size of the test for computing inference\nhs: if true, use Hall Sheather bandwidth when computing sparsity esimtates (not   applicable if inference is calculated via rank test inversion with iid regression errors)\niid:  if true, assume regression errors are iid; otherwise, assume that the conditional   quantile function is locally (in tau) linear (in x)\ninterpolate: if true, interpolate the confidence intervals produced by rank test   inversion inference; otherwise report values just above and just below each cutoff (only   applicable if inference is calculated via rank test inversion)\ntcrit: if true, use a Student's t distribution for calculating critical points;    otherwise use a normal distribution\nfit: QuantRegFit object storing the results of fitting the model\ninf: QuantRegInf object storing the results of computing inference for the model","category":"page"},{"location":"types/#Constructors-1","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"There are multiple ways to construct a QuantRegModel object. The preferred for end users constructor accepts a formula and dataset as positional arguments and model specifications as keyword arguments. Depending on the passed arguments, the constructor intelligently choses defaults for unspecified fields as described below and constructs empty QuantRegFit and QuantRegInf objects.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel(::StatsModels.FormulaTerm, ::DataFrames.DataFrame; ::Number,\n                       ::String, ::Union{Nothing, Bool}, ::Number, ::Bool,\n                       ::Union{Nothing, Bool}, ::Bool, ::Bool)","category":"page"},{"location":"types/#QuantReg.QuantRegModel-Tuple{FormulaTerm,DataFrame}","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(formula::FormulaTerm, data::DataFrame; τ::Number=0.5,\n              fitmethod::String=\"br\",invers::Union{Nothing, Bool}=nothing,\n              α::Number=0.05, hs::Bool=true, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Bool=true, tcrit::Bool=true)\n\nConstruct a quantile regression model at the τth quantile fitting data according to formula.\n\nIn any call, formula and data must be set. The logic for selecting values for unspecified parameters is as follows:\n\nτ: default is 0.5, i.e. median regression\nfitmethod: default method is the Barrodale-Roberts simplex\ninvers: default setting is true for datasets with 1000 or fewer observations and false   for larger datasets\nα: default setting is 0.05\nhs: default is true; always set to true when computing inference via rank test inversion\niid: default is true if computing inference via rank test inversion and false otherwise\ninterpolate: default is true\ntcrit: default is true\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"Additionally, one can construct a new QuantRegModel object from an existing QuantRegModel object by specifying parameters to change.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel(::QuantRegModel; ::Union{Nothing, Number}, ::Union{Nothing, String},\n              ::Union{Nothing, Bool}, ::Union{Nothing, Number}, hs::Union{Nothing, Bool},\n              ::Union{Nothing, Bool}, ::Union{Nothing, Bool}, ::Union{Nothing, Bool})","category":"page"},{"location":"types/#QuantReg.QuantRegModel-Tuple{QuantRegModel}","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(model::QuantRegModel; τ::Union{Nothing, Number}=nothing,\n              fitmethod::Union{Nothing, String}=nothing,\n              invers::Union{Nothing, Bool}=nothing, α::Union{Nothing, Number}=nothing,\n              hs::Union{Nothing, Bool}=nothing, iid::Union{Nothing, Bool}=nothing,\n              interpolate::Union{Nothing, Bool}=nothing,\n              tcrit::Union{Nothing, Bool}=nothing)\n\nConstruct a new quantile regression model by changing one or more parameters in an existing model.\n\nIf τ or method are unchanged, then the model fit is retained from the passed model but the model inference type is not.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"One particularly convient use caase for this constructor would be changing the test size or inference type for an existing model. For example, consider generating the following model:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Suppose after fitting this model, the use wanted to calculate 90% confidence intervals without recomputing the model fit. Such a change is nontrivial relative to standard linear regression because the Hall-Sheather bandwidth depends on the the confidence intervlals (as does the rank test inversion, if calcuating in that manner). To compute this change, the user could make employ the above constructor as follows:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> newmodel = QuantRegModel(model; α=0.10) # Generate model with new test size\njulia> compute_inf!(newmodel) # Compute inference for the modified model in-place","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Finally, the QuantRegModel object also has a default constructor. Use of the default constructor is strongly discouraged.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModel","category":"page"},{"location":"types/#QuantReg.QuantRegModel","page":"Types","title":"QuantReg.QuantRegModel","text":"QuantRegModel(formula::FormulaTerm, data::DataFrame, mf::ModelFrame, mm::ModelMatrix,\n              τ::Number, fitmethod::String, invers::Bool, α::Number, hs::Bool,\n              iid::Bool, interpolate::Bool, tcrit::Bool, fit::QuantRegFit,\n              inf::QuantRegInfe)\n\nContains a quantile regression model at the τth quantile fitting data according to formula.\n\nUse of this default constructor is not recommended. If rank test inversion is used to compute inference, then the Hall-Sheather bandwidths flag will always be set to true, overriding user choices.\n\n\n\n\n\n","category":"type"},{"location":"types/#Methods-1","page":"Types","title":"Methods","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"There is a method to create a deep copy of a QuantRegModel object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"deepcopy(::QuantReg.QuantRegModel)","category":"page"},{"location":"types/#Base.deepcopy-Tuple{QuantRegModel}","page":"Types","title":"Base.deepcopy","text":"deepcopy(model::QuantRegModel)\n\nCreate a deep copy of model (excluding data and formula).\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"There are also methods for the following StatsBase abstractions:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"StatsBase.coef\nStatsBase.coefnames\nStatsBase.coeftable\nStatsBase.confint\nStatsBase.dof\nStatsBase.dof_residual\nStatsBase.fitted\nStatsBase.isfitted\nStatsBase.islinear\nStatsBase.nobs\nStatsBase.stderr\nStatsBase.modelmatrix\nStatsBase.response\nStatsBase.responsename\nStatsBase.residuals","category":"page"},{"location":"types/#StatsBase.coef","page":"Types","title":"StatsBase.coef","text":"coef(obj::StatisticalModel)\n\nReturn the coefficients of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.coefnames","page":"Types","title":"StatsBase.coefnames","text":"coefnames(obj::StatisticalModel)\n\nReturn the names of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.coeftable","page":"Types","title":"StatsBase.coeftable","text":"coeftable(obj::StatisticalModel; level::Real=0.95)\n\nReturn a table of class CoefTable with coefficients and related statistics. level determines the level for confidence intervals (by default, 95%).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.confint","page":"Types","title":"StatsBase.confint","text":"confint(obj::StatisticalModel; level::Real=0.95)\n\nCompute confidence intervals for coefficients, with confidence level level (by default 95%).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.dof","page":"Types","title":"StatsBase.dof","text":"dof(obj::StatisticalModel)\n\nReturn the number of degrees of freedom consumed in the model, including when applicable the intercept and the distribution's dispersion parameter.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.dof_residual","page":"Types","title":"StatsBase.dof_residual","text":"dof_residual(obj::RegressionModel)\n\nReturn the residual degrees of freedom of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.fitted","page":"Types","title":"StatsBase.fitted","text":"fitted(obj::RegressionModel)\n\nReturn the fitted values of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.isfitted","page":"Types","title":"StatsBase.isfitted","text":"isfitted(obj::StatisticalModel)\n\nIndicate whether the model has been fitted.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.islinear","page":"Types","title":"StatsBase.islinear","text":"islinear(obj::StatisticalModel)\n\nIndicate whether the model is linear.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.nobs","page":"Types","title":"StatsBase.nobs","text":"nobs(obj::StatisticalModel)\n\nReturn the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.modelmatrix","page":"Types","title":"StatsBase.modelmatrix","text":"modelmatrix(obj::RegressionModel)\n\nReturn the model matrix (a.k.a. the design matrix).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.response","page":"Types","title":"StatsBase.response","text":"response(obj::RegressionModel)\n\nReturn the model response (a.k.a. the dependent variable).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.responsename","page":"Types","title":"StatsBase.responsename","text":"responsename(obj::RegressionModel)\n\nReturn the name of the model response (a.k.a. the dependent variable).\n\n\n\n\n\n","category":"function"},{"location":"types/#StatsBase.residuals","page":"Types","title":"StatsBase.residuals","text":"residuals(obj::RegressionModel)\n\nReturn the residuals of the model.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"Types","title":"Types","text":"As well as a method to nicely print the results of a model:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.show(::IO, ::QuantRegModel)","category":"page"},{"location":"types/#Base.show-Tuple{IO,QuantRegModel}","page":"Types","title":"Base.show","text":"show(io::IO, model::QuantRegModel)\n\nDisplay quantreg model.\n\n\n\n\n\n","category":"method"},{"location":"types/#QuantRegModels-1","page":"Types","title":"QuantRegModels","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.jl also contains a QuantRegModels type that enables users to store multiple models at different τ values. This type is a hybrid between a dictionary and a list, so that models are always indexed by the τ value for which they are fit. A single QuantRegModels object cannot contain multiple models with the same τ value. ","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"note: Note\nThe primary intent of these objects is to store quantile regression models with the exact same specifications aside from τ, though this is not strictly enforced. The internal implementation may change in the future, however, so other uses are strongly discouraged.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Currently, a QuantRegModel has a single field, models, which stores all the QuantRegModel objects in a dictionary indexed by τ value. This dictionary should not be modified directly.","category":"page"},{"location":"types/#Constructor-1","page":"Types","title":"Constructor","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"This type has one constructor, which always creates an empty QuantRegModels object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.QuantRegModels","category":"page"},{"location":"types/#QuantReg.QuantRegModels","page":"Types","title":"QuantReg.QuantRegModels","text":"QuantRegModels()\n\nWrapper containing multiple QuantRegModel at different quantiles indexed by quantile. \n\nThis method partically implements some behaviors of a dictionary (for easy indexing) and some behaviors of an array (for easy, consistent appends). This type is not intended to be directly created by most end users.\n\nFor example, if a models::QuantRegModels contained models with τ=0.25, 0.5 and 0.75, these models could be accessed as models[0.25], models[0.5], and models[0.75] respectively.\n\n\n\n\n\n","category":"type"},{"location":"types/#Methods-2","page":"Types","title":"Methods","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"As a hybrid of an array and a dictionary, some methods intended for arrays and some intended for dictionaries are implemented for QuantRegModels.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"For example, to add a new model to a QuantRegModels, one should use append!. This method ensures that the underlying dictionary exclusively contains QuantRegModel objects, that the models are indexed by their τ value, and that each QuantRegModels object contains no more than one QuantRegModel for a given τ value. ","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.append!(::QuantReg.QuantRegModels, ::QuantReg.QuantRegModels)","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"A getindex method is implemented for this type, so users can access a particular model via the following syntax","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> models[τ]","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"where models is a QuantRegModels object and τ  is a τ value for a QuantRegModel stored in models.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.getindex(::QuantReg.QuantRegModels, ::Number)","category":"page"},{"location":"types/#Base.getindex-Tuple{QuantReg.QuantRegModels,Number}","page":"Types","title":"Base.getindex","text":"getindex(X::QuantRegModels, τ::Number)\n\nReturns the model in X fit at the τth quantile.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"Types","title":"Types","text":"There are also two methods, taus and hastau, which respectively display all the τ values for which a given QuantRegModels object contains a model and checks whther a given QuantRegModels object contains a model for a specific value of τ.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"QuantReg.taus\nQuantReg.hastau","category":"page"},{"location":"types/#QuantReg.taus","page":"Types","title":"QuantReg.taus","text":"taus(X::QuantRegModels)\n\nRetrive all the τ values for models stored in X.\n\n\n\n\n\n","category":"function"},{"location":"types/#QuantReg.hastau","page":"Types","title":"QuantReg.hastau","text":"getindex(X::QuantRegModels, τ::Number)\n\nCheck if X contains a model at the τth percentile.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"Types","title":"Types","text":"Lastly, there is also an implementation of show which nicely displays all the models in a QuantRegModels object.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Base.show(::QuantReg.QuantRegModels)","category":"page"},{"location":"quickstart/#Quickstart-1","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation-1","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"QuantReg.jl is not currently available via the Julia general repository and must be installed from GitHub.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"From the Pkg REPL, run the following command:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"pkg> add https://github.com/fogarty-ben/QuantReg.jl","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Alternatively, run the following commands from the Julia REPL:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> using Pkg;  \njulia> Pkg.add(PackageSpec(url=\"https://github.com/fogarty-ben/QuantReg.jl\", rev=\"master\"))","category":"page"},{"location":"quickstart/#Running-your-first-model-1","page":"Quickstart","title":"Running your first model","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"The easiest way to generate, fit, and compute inference for a quantile regression model is via the rq command.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> using CSV, QuantReg\njulia> df = CSV.read(\"/path/to/data.csv\") # load dataset to fit\njulia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.50)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"The resulting object model contains a median regression fitted and with inference computed according to default settings. For more information on default settings, see the type(QuantRegModel) reference.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Withing the result object, model.fit contains the results of fitting the model, including the coefficients, residuals, fitted values, and, for some fitting methods, the solution to the dual problem. For more information on how to access these values, see the type(QuantRegFit) reference.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"model.inf containts the results of computing inference for the model, encompasses confidence interval bounds if a rank test inversion is used to compute inference and encompasses standard errors, test statistics, p-values, and confidence interval bounds if inference is computed using asymptotic estimates of the covariance matrix. For more information on how to access these values, see the type(QuantRegInf) reference.","category":"page"},{"location":"quickstart/#Running-models-at-multiple-quantiles-1","page":"Quickstart","title":"Running models at multiple quantiles","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"It is also possible to fit more than one model simultaneously by passing an array of τ  values. ","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> models = rq(@formula(Y ~ X1 + X2 + X3), df; τ=[0.25, 0.50, 0.75])","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"This call yields a QuantRegModels object containing three quantile regression models, fit at the 0.25th, 0.50th, and 0.75th quantiles. The individual models can be accessed by using the τ values as indices. For example,","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> models[0.25]","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"will return the quantile regression model fit at the 0.25th quantile.","category":"page"},{"location":"quickstart/#Configuring-models-1","page":"Quickstart","title":"Configuring models","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Users can provide more detailed model specifications as keyword arguments to the quantile regression command. Any specification fields in the [QuantRegModel][@ref] type can be accepted as a keyword argument. The following command fits a quantile regression model at the 0.80th quantile using the Frisch-Newton and computes 80% confidence intervals under the assumption that the conditional quantile function is locally (in tau) linear (in x) (i.e. regression errors are not i.i.d.).","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"rq","category":"page"},{"location":"quickstart/#QuantReg.rq","page":"Quickstart","title":"QuantReg.rq","text":"rq(formula::FormulaTerm, data::DataFrame; kwargs)\n\nGenerate, fit, and compute inference for the specified quantile regression model.\n\nAcceptable kwargs are the same as those accepted by QuantRegModel.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Under-the-hood-of-rq-1","page":"Quickstart","title":"Under the hood of rq","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"In code, the rq functions is really a wrapper for three functions that constitute a common work flow. It first constructs a QuantRegModel object according to the specifications provided. Then, it fits the model in place according to the specifications in the generated model object with func(fit!). This function call updates the QuantRegFit object stored in the model object. Finally, it computes inference for the model according to the specifications in the generated model object with func(compute_inf!). This function call updates the QuantRegInf object stored in the model object.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"For example, the call:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, iid=false)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"is equivalent to:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"julia> model = QuantRegModel(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, \n                             iid=false)\njulia> fit!(model)\njulia> compute_inf!(model)","category":"page"},{"location":"fitting/#Fitting-Quantile-Regression-Models-1","page":"Fitting models","title":"Fitting Quantile Regression Models","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.jl currently contains three methods for fitting quantile regression models: (1) the Barrodale-Roberts simple algorithm, (2) the Frisch-Newton algorithm, and (3) via the industrial solver Gurobi. The first two methods leverage FORTRAN code originally written for the R quantreg package. The third method was developed specifically for this package and only works if Gurobi is already installed on the user's machine.","category":"page"},{"location":"fitting/#Generic-functions-1","page":"Fitting models","title":"Generic functions","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"A QuantRegModel object, named model, can be fit using the generic fit!() function, and indeed this is the function that most end users will leverage. This functions fits the object in place, modifying the QuantRegFit object stored at model.fit. For example,","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"julia> model = QuantRegModel(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\")","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"creates an unfitted a quantile regression model at the 0.80th quantile and specifies for it to be fit via the Frisch-Newton. Then,","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"julia> fit!(model)","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"fits the model in-place via the specified method.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Additionaly, there is a fit() method that creates a deep copy of the passed model, fits that copy, and returns the new, fitted model.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fit!\nQuantReg.fit","category":"page"},{"location":"fitting/#StatsBase.fit!","page":"Fitting models","title":"StatsBase.fit!","text":"Fit a statistical model in-place.\n\n\n\n\n\nfit!(model::QuantRegModel)\n\nFit model in-place according to model.fit.method.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#QuantReg.fit","page":"Fitting models","title":"QuantReg.fit","text":"fit(model::QuantRegModel)\n\nDeep copy model and fit according to model.fit.method.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"Ultimately, these two functions simply serve as a one-stop wrapper for fitting a model and call different subroutines depending on the value of model.fitmethod.","category":"page"},{"location":"fitting/#Choosing-a-fitting-method-1","page":"Fitting models","title":"Choosing a fitting method","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"TODO: Write about simulation results *","category":"page"},{"location":"fitting/#Barrodale-Roberts-Simplex-Method-1","page":"Fitting models","title":"Barrodale-Roberts Simplex Method","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The Barrodale-Roberts simplex algorithm implemented can be used for both fitting the model and for computing inference via a rank test inversion. When fitting, the following method is called with the keyword argument, ci, set to its default value of false.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"br\" in either the rq function of the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitbr!","category":"page"},{"location":"fitting/#QuantReg.fitbr!","page":"Fitting models","title":"QuantReg.fitbr!","text":"fitbr!(model::QuantRegModel; ci::Bool=false),\n\nFit model using the Barrodale-Roberts method.\n\nIf ci is false, model.fit is updated in place to reflect the fit produced by running the Barrodale-Roberts simplex, and confidence intervals are not computed. Otherwise, confidence intervals are computed, and model.inf is updated in place to reflect the confidence invervals produced by this method, but model.fit is not updated.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"This method relies on a subroutine, fitbrfortran, that handles the FORTRAN call.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitbr!","category":"page"},{"location":"fitting/#Frisch-Newton-Algorithm-1","page":"Fitting models","title":"Frisch-Newton Algorithm","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The Frisch-Newton algorithm implemented is an interior point method that can be used to solve quantile regression problems. Unlike the other two methods in this package, this method does not produce solutions to the dual problem.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"fn\" in either the rq function of the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitfn!","category":"page"},{"location":"fitting/#QuantReg.fitfn!","page":"Fitting models","title":"QuantReg.fitfn!","text":"fitfn!(model::QuantRegModel)\n\nFit model using the Frish-Newton algorithm.\n\nFitting with this method does not produce solutions to the dual problem.\n\nThis fitting method leverages public domain FORTRAN code written by Roger Koenker for the R quantreg package. In the quantreg package, this is equivalent to the fn and fnb methods.\n\n\n\n\n\n","category":"function"},{"location":"fitting/#Gurobi-1","page":"Fitting models","title":"Gurobi","text":"","category":"section"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"The only fitting method available via this package that is not available via the R quantreg package is fitting via Gurobi. This fitting method is only available to users who already have a licensed version of Gurobi installed on their machine and the Gurobi.jl package added in Julia. Note that Gurobi.jl is not installed as a dependency of QuantReg.jl so that the package is accessible to users without a licensed version of Gurobi (the package Gurobi.jl cannot be properly installed without a licensed version of Gurobi). Further note that even if an active Gurobi license is installed on the user's machine, the GUROBI_HOME environmental variable must be properly set for the Gurobi fitting method to be available.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"To select this method when specifying a quantile regression model, set the keyword argument fitmethod=\"fn\" in either the gurobi function of the QuantRegModel constructor.","category":"page"},{"location":"fitting/#","page":"Fitting models","title":"Fitting models","text":"QuantReg.fitgurobi!","category":"page"},{"location":"fitting/#QuantReg.fitgurobi!","page":"Fitting models","title":"QuantReg.fitgurobi!","text":"fitgurobi(model::QuantRegModel)\n\nFit model using Gurobi via Julia's JuMP library.\n\nThis algorithm has been tailored specifically to work with Julia (hence the use of direct) mode. Some time was spent researching the use of open-source solvers such as GLPK, but they proved to be too slow. Extending this method to work with other solvers, such as CPLEX could be accomplished by switching the optimizer and creating the model in automatic mode, but this may leave some small efficiency gains on the table.\n\n\n\n\n\n","category":"function"},{"location":"#QuantReg.jl-Documentation-1","page":"Introduction","title":"QuantReg.jl Documentation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package provides types and functions for specifying, fitting, and computing inference for quantile regression models. This package was originally modeled after the R package quantreg, authored by Roger Koenker. Currently, the packages implements many of the abstractions for statistical models from StatsBase.jl and requires tabular data in the form of a DataFrame.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Contributions to this packages that incorporate more features from the R quantreg package, add new features, or refine existing features are welcomed and encouraged on the project's GitHub. Please feel free to open an issue or pull request!","category":"page"},{"location":"inference/#Computing-Inference-for-Quantile-Regression-Models-1","page":"Inference","title":"Computing Inference for Quantile Regression Models","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.jl currently contains two primary methods for computing inference of a quantile regression model: (1) via a rank test inversion and (2) via an asymptotic estimate of the covariance matrix. The choice between these methods is determined by the invers flag in a QuantRegModel object:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"invers: if true, compute confidence intervals by inverting a rank test (only recommended   for datasets with <= 1000 observations); otherwise, use an asymptotic esimtate of the   covariance matrix","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Within each of these primary methods, there are a number of suboptions:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"α: size of the test for computing inference; be aware that this can affect results   beyond the confidence intervals inf the Hall Sheather bandwidth is being used\nhs: if true, use Hall Sheather bandwidth when computing sparsity esimtates (not   applicable if inference is calculated via rank test inversion with iid regression   errors as there is no need to estimate a bandwidth in this case)\niid:  if true, assume regression errors are iid; otherwise, assume that the conditional   quantile function is locally (in tau) linear (in x)\ninterpolate: if true, interpolate the confidence intervals produced by rank test   inversion inference; otherwise report values just above and just below each cutoff (only   applicable if inference is calculated via rank test inversion)\ntcrit: if true, use a Student's t distribution for calculating critical points;    otherwise use a standard normal distribution","category":"page"},{"location":"inference/#Generic-functions-1","page":"Inference","title":"Generic functions","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Much like the fit! and fit functions, inference for a QuantRegModel object, named model, can be computed using the generic compute_inf!(model) and compute_inf(model)  functions. The compute_inf! functions fits the object in place, modifying the QuantRegInf object stored at model.inf. The compute_inf() method creates a deep copy of the passed model, computes inference for the copied model, and returns the new model. For example:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=\"fn\", α=0.20, invers=true,\n          iid=false)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"creates an unfitted a quantile regression model at the 0.80th quantile and specifies for it to be fit via the Frisch-Newton. Inference is conducted via a rank test inversion under the assumpton that the conditional quantile function is locally (in tau) linear (in x) to produce 80% Confidence Intervals. Then:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> fit!(model)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"fits the model in place via the specified method. And finally:","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"julia> compute_inf!(model)","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"computes inference in place as specified. Note that a model must be fit before inference can be computed.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_inf!\nQuantReg.compute_inf","category":"page"},{"location":"inference/#QuantReg.compute_inf!","page":"Inference","title":"QuantReg.compute_inf!","text":"compute_inf!(model)\n\nIn-place version of [compute_inf!(model)]\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.compute_inf","page":"Inference","title":"QuantReg.compute_inf","text":"compute_inf(model::QuantRegModel)\n\nCompute inference for model as specified in model.inf.\n\n\n\n\n\n","category":"function"},{"location":"inference/#","page":"Inference","title":"Inference","text":"Ultimately, these two functions simply serve as a one-stop wrapper for computing inference and call different subroutines depending on the specifications of the model.","category":"page"},{"location":"inference/#Rank-Test-Inversion-1","page":"Inference","title":"Rank Test Inversion","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"To compute confidence intervals by inverting a rank test, this algorithm leverages the same function and FORTRAN routine for fitting a model with the Barrodale-Roberts simplex  algorithm. In this case, however, the optinal argument, ci is set to true.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.fitbr!","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"There are three subroutines specific to computing inference vai rank test inversion. End users should not need to call these directly.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_nid_qn_invers\nQuantReg.init_ci_invers\nQuantReg.write_ci!","category":"page"},{"location":"inference/#QuantReg.compute_nid_qn_invers","page":"Inference","title":"QuantReg.compute_nid_qn_invers","text":"compute_nid_qn_invers(i::Integer, data::DataFrame, regressors::Array{<:AbstractTerm},\n                  weights::Array{<:Number})\n\nComputes residuals variances from the projection of each column of X on remaining columns for rank test inversion inference under the n.i.d. assumption.\n\nThis function should be of little interest to end users as it is primarily a helper function for computing inference with a rank test inversion and with n.i.d. errors.\n\nArguments\n\ni: enumeration of column to project\ndata: data used to fit the model\nregressors: list of regressors from the model\nweights: weight to use in calculating projection as a linear regression\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.init_ci_invers","page":"Inference","title":"QuantReg.init_ci_invers","text":"init_inf_invers(model::QuantRegModel)\n\nInitialize necessary values for calculating confidence intervals for model with a rank test inversion. \n\nThis function should be of little interest to end users as it is solely used as a subroutine when calling [fitbr(model; ci=true)].\n\n\n\n\n\n","category":"function"},{"location":"inference/#QuantReg.write_ci!","page":"Inference","title":"QuantReg.write_ci!","text":"write_ci(model::QuantRegModel, ci::Array{Number, 2})\n\nWrite ranks test inversion confidence intervals to model.inf.\n\nci should be a set of  confidence interval matrix produced by a call to [fitbr(model; ci=true)].\n\n\n\n\n\n","category":"function"},{"location":"inference/#Asymptotic-Estimate-of-Covariance-Matrix-1","page":"Inference","title":"Asymptotic Estimate of Covariance Matrix","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"The package can compute inference via an asymptotic estimate of the covariance directly in Julia using one of two functions, compute_σ_iid_asy for if regression errors are assumed to be iid and compute_σ_nid_asy otherwise. These functions are closely modeled on analgous  code in the R quantreg pakage.","category":"page"},{"location":"inference/#","page":"Inference","title":"Inference","text":"QuantReg.compute_σ_iid_asy!\nQuantReg.compute_σ_nid_asy!","category":"page"},{"location":"inference/#Subroutines-1","page":"Inference","title":"Subroutines","text":"","category":"section"},{"location":"inference/#","page":"Inference","title":"Inference","text":"In addition, there is a subroutine, compute_bandwidth that is used to calculate the τ bandwidth for sparsity estimation in both of the methods for calculatig inference.","category":"page"}]
}

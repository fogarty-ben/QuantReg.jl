<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · QuantReg.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantReg.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li class="is-active"><a class="tocitem" href>Types</a><ul class="internal"><li><a class="tocitem" href="#QuantRegFit-1"><span>QuantRegFit</span></a></li><li><a class="tocitem" href="#QuantRegInf-1"><span>QuantRegInf</span></a></li><li class="toplevel"><a class="tocitem" href="#QuantRegModel-1"><span>QuantRegModel</span></a></li><li><a class="tocitem" href="#QuantRegModels-1"><span>QuantRegModels</span></a></li></ul></li><li><a class="tocitem" href="../fitting/">Fitting models</a></li><li><a class="tocitem" href="../inference/">Inference</a></li><li><a class="tocitem" href="../example/">Example usage</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fogarty-ben/QuantReg.jl/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantReg.jl-Types-1"><a class="docs-heading-anchor" href="#QuantReg.jl-Types-1">QuantReg.jl Types</a><a class="docs-heading-anchor-permalink" href="#QuantReg.jl-Types-1" title="Permalink"></a></h1><p>The QuantReg.jl package introduces four types: <a href="#QuantRegFit-1">QuantRegFit</a>, <a href="#QuantRegInf-1">QuantRegInf</a>, <a href="#QuantRegModel-1">QuantRegModel</a>, and <a href="#QuantRegModels-1">QuantRegModels</a>. For most users, a deep understanding of these types is unnecessary, but the structure of these types will be helpful for advanced users, students investigating the properties of quantile regression, or developers wishing to extend the package.</p><p>These four types work together as follows: a <code>QuantRegModel</code> is an immutable object and contains all of the specification necessary to fit and compute inference for a model plus a <code>QuantRegFit</code> and<code>QuantRegInf</code> objects to store the results of fitting the model and computing inference, respectively. A <code>QuantRegModels</code> object stores multiple <code>QuantRegModel</code> objects, indexed by their τ values; note that a <code>QuantRegModels</code> object cannot contain multple <code>QuantRegModel</code> objects with the same τ value.</p><h2 id="QuantRegFit-1"><a class="docs-heading-anchor" href="#QuantRegFit-1">QuantRegFit</a><a class="docs-heading-anchor-permalink" href="#QuantRegFit-1" title="Permalink"></a></h2><p><code>QuantRegFit</code> objects store the results of fitting a quantile regression model and are mutable. Each instance contains the following fields:</p><ul><li><code>computed</code>: denotes whether or not the parent model has been fit</li><li><code>coef</code>: stores the coefficients for a fitted model or nothing if   model hasn&#39;t been fit</li><li><code>resid</code>: stores the residuals for each observation or nothing if   the model hasn&#39;t been fit</li><li><code>dual</code>: stores the solution to the dual problem if the fitting   method produces the dual solution or nothing if the model hasn&#39;t been fit or the fitting   method does not produce the dual solution</li><li><code>yhat</code>: stores the fitted values for the dataset used to build the   model or nothing if the model hasn&#39;t been fit</li></ul><p><code>QuantRegFit</code> has one construtor, the default constructor in which all field values are specified directly. <code>QuantRegFit</code> objects are primarily constructed in the creation of <code>QuantRegModel</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegFit" href="#QuantReg.QuantRegFit"><code>QuantReg.QuantRegFit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantReg.QuantRegFit(computed::Bool, coef::Union{Vector{&lt;:Number}, Nothing},
                     resid::Union{Vector{&lt;:Number}, Nothing}, 
                     dual::Union{Vector{&lt;:Number}, Nothing},
                     yhat::Union{Vector{&lt;:Number}, Nothing})</code></pre><p>Stores results of fitting a quantile regression model.</p><p><code>coef</code>, <code>resid</code>, <code>dual</code>, and <code>yhat</code> should be set to <code>nothing</code> until a model is fit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L1-L10">source</a></section></article><p>Additionally, there is a method to create deep copies of <code>QuantRegFit</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy-Tuple{QuantReg.QuantRegFit}" href="#Base.deepcopy-Tuple{QuantReg.QuantRegFit}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepcopy(fit::QuantRegFit)</code></pre><p>Create a deep copy of <code>fit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L19-L23">source</a></section></article><h2 id="QuantRegInf-1"><a class="docs-heading-anchor" href="#QuantRegInf-1">QuantRegInf</a><a class="docs-heading-anchor-permalink" href="#QuantRegInf-1" title="Permalink"></a></h2><p>Similarly, <code>QuantRegInf</code> objects store the results of computing inference for a quantile regression model and are mutable. Each instance contains the following fields:</p><ul><li><code>computed</code>: denotes whether or not inference has been computed for the parent model</li><li><code>lowerci</code>: lower bounds for the specified confidence intervals or nothing if inference   hasn&#39;t been computed for the model; a (k x 1) matrix unless inference is computed via    rank test inversion and interpolate is set to false, in which case a (k x 2) matrix</li><li><code>upperci</code>: upper bounds for the specified confidence intervals or nothing if inference   hasn&#39;t been computed for the model; a (k x 1) matrix unless inference is computed via   rank test inversion and interpolate is set to false, in which case a (k x 2) matrix</li><li><code>σ</code>: standard errors for the coefficients or nothing if inference hasn&#39;t been computed   for the model or is calculated via a rank test inversion</li><li><code>teststat</code>: t or z statistics for the coefficients or nothing if inference hasn&#39;t been   computed for the model or is calculated via a rank test inversion</li><li><code>p</code>: p values for the coefficients or nothing if inference hasn&#39;t been computed for the   model or is calculated via a rank test inversion</li></ul><p><code>QuantRegInf</code> also has one construtor, the default constructor in which all field values are specified directly. <code>QuantRegFit</code> objects are primarily constructed in the creation of <code>QuantRegModel</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegInf" href="#QuantReg.QuantRegInf"><code>QuantReg.QuantRegInf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantReg.QuantRegInf(computed::Bool,
                     lowerci::Union{Nothing, Vector{&lt;:Number}, Matrix{&lt;:Number}}
                     upperci::Union{Nothing, Vector{&lt;:Number}, Matrix{&lt;:Number}}
                     σ::Union{Nothing, Vector{&lt;:Number}}
                     teststat::Union{Nothing, Vector{&lt;:Number}}
                     p::Union{Nothing, Vector{&lt;:Number}})</code></pre><p>Stores results of computing inference for a quantile regression model.</p><p><code>lowerci</code>, <code>upperci</code>, <code>σ</code>, <code>teststat</code>, and <code>p</code> should be set to <code>nothing</code> until inference is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L34-L47">source</a></section></article><p>Additionally, there is a method to create deep copies of <code>QuantRegInf</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy-Tuple{QuantReg.QuantRegInf}" href="#Base.deepcopy-Tuple{QuantReg.QuantRegInf}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepcopy(inf::QuantRegInf)</code></pre><p>Create a deep copy of <code>inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L58-L62">source</a></section></article><h1 id="QuantRegModel-1"><a class="docs-heading-anchor" href="#QuantRegModel-1">QuantRegModel</a><a class="docs-heading-anchor-permalink" href="#QuantRegModel-1" title="Permalink"></a></h1><p><code>QuantRegModel</code> is the type with which end users are most likely to interact. <code>QuantRegModel</code> objects are immutable and contain the following fields:</p><ul><li><code>formula</code>: the formula to fit the data</li><li><code>data</code>: DataFrame object containing data to fit the model with</li><li><code>mf</code>: ModelFrame object created by applying <code>formula</code> to <code>data</code></li><li><code>mm</code>: ModelMatrix object created from <code>mf</code></li><li><code>τ</code>: quantile to fit the model at</li><li><code>fitmethod</code>: the algorithm/method to fit the model; available options are:<ul><li><code>&quot;br&quot;</code>: fit using Barrodale-Roberts simplex (default method)</li><li><code>&quot;fn&quot;</code>: Fit using Frisch-Newton algorithm</li><li><code>&quot;gurobi&quot;</code>: Fit using Gurobi (must have Gurobi installed)</li></ul></li><li><code>invers</code>: if true, compute confidence intervals by inverting a rank test (only recommended   for datasets with &lt;= 1000 observations); otherwise, use an asymptotic esimtate of the   covariance matrix</li><li><code>α</code>: size of the test for computing inference</li><li><code>hs</code>: if true, use Hall Sheather bandwidth when computing sparsity estimates (not   applicable if inference is calculated via rank test inversion with iid regression errors)</li><li><code>iid</code>:  if true, assume regression errors are iid; otherwise, assume that the conditional   quantile function is locally (in tau) linear (in x)</li><li><code>interpolate</code>: if true, interpolate the confidence intervals produced by rank test   inversion inference; otherwise report values just above and just below each cutoff (only   applicable if inference is calculated via rank test inversion)</li><li><code>tcrit</code>: if true, use a Student&#39;s t distribution for calculating critical points;    otherwise use a normal distribution</li><li><code>fit</code>: <code>QuantRegFit</code> object storing the results of fitting the model</li><li><code>inf</code>: <code>QuantRegInf</code> object storing the results of computing inference for the model</li></ul><h3 id="Constructors-1"><a class="docs-heading-anchor" href="#Constructors-1">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-1" title="Permalink"></a></h3><p>There are multiple ways to construct a <code>QuantRegModel</code> object. The most relevant one for end users accepts a formula and dataset as positional arguments and model specifications as keyword arguments. Depending on the passed arguments, the constructor intelligently choses defaults for unspecified fields as described below and constructs empty <code>QuantRegFit</code> and <code>QuantRegInf</code> objects.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegModel-Tuple{FormulaTerm,DataFrame}" href="#QuantReg.QuantRegModel-Tuple{FormulaTerm,DataFrame}"><code>QuantReg.QuantRegModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantRegModel(formula::FormulaTerm, data::DataFrame; τ::Number=0.5,
              fitmethod::String=&quot;br&quot;,invers::Union{Nothing, Bool}=nothing,
              α::Number=0.05, hs::Bool=true, iid::Union{Nothing, Bool}=nothing,
              interpolate::Bool=true, tcrit::Bool=true)</code></pre><p>Construct a quantile regression model at the <code>τ</code>th quantile fitting <code>data</code> according to <code>formula</code>.</p><p>In any call, <code>formula</code> and <code>data</code> must be set. The logic for setting values of unspecified parameters is as follows:</p><ul><li><code>τ</code>: default is 0.5, i.e. median regression</li><li><code>fitmethod</code>: default method is the Barrodale-Roberts simplex</li><li><code>invers</code>: default setting is true for datasets with 1000 or fewer observations and false   for larger datasets</li><li><code>α</code>: default setting is 0.05</li><li><code>hs</code>: default is true; always set to true when computing inference via rank test inversion</li><li><code>iid</code>: default is true if computing inference via rank test inversion and false otherwise</li><li><code>interpolate</code>: default is true</li><li><code>tcrit</code>: default is true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L115-L135">source</a></section></article><p>Additionally, one can construct a new <code>QuantRegModel</code> object from an existing <code>QuantRegModel</code> object by specifying parameters to change.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegModel-Tuple{QuantRegModel}" href="#QuantReg.QuantRegModel-Tuple{QuantRegModel}"><code>QuantReg.QuantRegModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantRegModel(model::QuantRegModel; τ::Union{Nothing, Number}=nothing,
              fitmethod::Union{Nothing, String}=nothing,
              invers::Union{Nothing, Bool}=nothing, α::Union{Nothing, Number}=nothing,
              hs::Union{Nothing, Bool}=nothing, iid::Union{Nothing, Bool}=nothing,
              interpolate::Union{Nothing, Bool}=nothing,
              tcrit::Union{Nothing, Bool}=nothing)</code></pre><p>Construct a new quantile regression model by changing one or more parameters in an existing model.</p><p>If <code>τ</code> or <code>method</code> are unchanged, then the model fit is copied from the passed model but the model inf is not. Otherwise, neither is copied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L166-L179">source</a></section></article><p>One particularly convient use caase for this constructor would be changing the test size or inference type for an existing model. For example, consider generating the following model:</p><pre><code class="language-none">julia&gt; model = rq(@formula(Y ~ X1 + X2 + X3), df; τ=0.80, fitmethod=&quot;fn&quot;, α=0.20, iid=false)</code></pre><p>Suppose after fitting this model, the user wants to calculate 90% confidence intervals without recomputing the model fit. Such a change is nontrivial because the Hall-Sheather bandwidth depends on the the confidence interval size. To compute this change, the user could employ the above constructor as follows:</p><pre><code class="language-none">julia&gt; newmodel = QuantRegModel(model; α=0.10) # Generate model with new test size
julia&gt; compute_inf!(newmodel) # Compute inference for the modified model in-place</code></pre><p>Finally, the <code>QuantRegModel</code> object also has a default constructor. Use of the default constructor is <em>strongly discouraged</em>.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegModel" href="#QuantReg.QuantRegModel"><code>QuantReg.QuantRegModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantRegModel(formula::FormulaTerm, data::DataFrame, mf::ModelFrame, mm::ModelMatrix,
              τ::Number, fitmethod::String, invers::Bool, α::Number, hs::Bool,
              iid::Bool, interpolate::Bool, tcrit::Bool, fit::QuantRegFit,
              inf::QuantRegInfe)</code></pre><p>Contains a quantile regression model at the <code>τ</code>th quantile fitting <code>data</code> according to <code>formula</code>.</p><p>Use of this default constructor is not recommended. If rank test inversion is used to compute inference, then the Hall-Sheather bandwidth flag will always be set to true, overriding user input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L74-L86">source</a></section></article><h3 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h3><p>There is a method to create a deep copy of a <code>QuantRegModel</code> object.</p><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy-Tuple{QuantRegModel}" href="#Base.deepcopy-Tuple{QuantRegModel}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepcopy(model::QuantRegModel)</code></pre><p>Create a deep copy of <code>model</code> (excluding data and formula).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L219-L223">source</a></section></article><p>There are also methods for the following StatsBase abstractions:</p><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coef" href="#StatsBase.coef"><code>StatsBase.coef</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coef(obj::StatisticalModel)</code></pre><p>Return the coefficients of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coefnames" href="#StatsBase.coefnames"><code>StatsBase.coefnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coefnames(obj::StatisticalModel)</code></pre><p>Return the names of the coefficients.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coeftable" href="#StatsBase.coeftable"><code>StatsBase.coeftable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coeftable(obj::StatisticalModel; level::Real=0.95)</code></pre><p>Return a table of class <code>CoefTable</code> with coefficients and related statistics. <code>level</code> determines the level for confidence intervals (by default, 95%).</p></div></section><section><div><pre><code class="language-none">coeftable(model::QuantRegModel)</code></pre><p>Return a table of class CoefTable with coefficients and related statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.confint-Tuple{QuantRegModel}" href="#StatsBase.confint-Tuple{QuantRegModel}"><code>StatsBase.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">confint(obj::StatisticalModel; level::Real=0.95)</code></pre><p>Compute confidence intervals for coefficients, with confidence level <code>level</code> (by default 95%).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.dof" href="#StatsBase.dof"><code>StatsBase.dof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dof(obj::StatisticalModel)</code></pre><p>Return the number of degrees of freedom consumed in the model, including when applicable the intercept and the distribution&#39;s dispersion parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.dof_residual" href="#StatsBase.dof_residual"><code>StatsBase.dof_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dof_residual(obj::RegressionModel)</code></pre><p>Return the residual degrees of freedom of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fitted" href="#StatsBase.fitted"><code>StatsBase.fitted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fitted(obj::RegressionModel)</code></pre><p>Return the fitted values of the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.isfitted" href="#StatsBase.isfitted"><code>StatsBase.isfitted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isfitted(obj::StatisticalModel)</code></pre><p>Indicate whether the model has been fitted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.islinear" href="#StatsBase.islinear"><code>StatsBase.islinear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">islinear(obj::StatisticalModel)</code></pre><p>Indicate whether the model is linear.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.nobs" href="#StatsBase.nobs"><code>StatsBase.nobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nobs(obj::StatisticalModel)</code></pre><p>Return the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.modelmatrix" href="#StatsBase.modelmatrix"><code>StatsBase.modelmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modelmatrix(obj::RegressionModel)</code></pre><p>Return the model matrix (a.k.a. the design matrix).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.response" href="#StatsBase.response"><code>StatsBase.response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">response(obj::RegressionModel)</code></pre><p>Return the model response (a.k.a. the dependent variable).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.responsename" href="#StatsBase.responsename"><code>StatsBase.responsename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">responsename(obj::RegressionModel)</code></pre><p>Return the name of the model response (a.k.a. the dependent variable).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.residuals" href="#StatsBase.residuals"><code>StatsBase.residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">residuals(obj::RegressionModel)</code></pre><p>Return the residuals of the model.</p></div></section></article><p>As well as a method to nicely print the results of a model:</p><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,QuantRegModel}" href="#Base.show-Tuple{IO,QuantRegModel}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, model::QuantRegModel)</code></pre><p>Display a quantreg model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L298-L302">source</a></section></article><h2 id="QuantRegModels-1"><a class="docs-heading-anchor" href="#QuantRegModels-1">QuantRegModels</a><a class="docs-heading-anchor-permalink" href="#QuantRegModels-1" title="Permalink"></a></h2><p>QuantReg.jl also contains a <code>QuantRegModels</code> type that enables users to store multiple models at different τ values. This type is a hybrid between a dictionary and a list so that models are always indexed by the τ value for which they are fit. A single <code>QuantRegModels</code> object cannot contain multiple models with the same τ value. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The primary intent of these objects is to store quantile regression models with the exact same specifications aside from τ, but this pattern is not strictly enforced. The internal implementation may change in the future, however, so other uses are <em>strongly</em> discouraged.</p></div></div><p>Currently, a <code>QuantRegModels</code> object has a single field, <code>models</code>, which stores <code>QuantRegModel</code> objects in a dictionary indexed by their τ values. This dictionary should <em>not</em> be modified directly.</p><h3 id="Constructor-1"><a class="docs-heading-anchor" href="#Constructor-1">Constructor</a><a class="docs-heading-anchor-permalink" href="#Constructor-1" title="Permalink"></a></h3><p>This type has one constructor, which always creates an empty <code>QuantRegModels</code> object.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.QuantRegModels" href="#QuantReg.QuantRegModels"><code>QuantReg.QuantRegModels</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantRegModels()</code></pre><p>Wrapper containing multiple QuantRegModel at different quantiles indexed by quantile. </p><p>This method implements some behaviors of a dictionary (for easy indexing) and some behaviors of an array (for easy, consistent appends). This type is not intended to be directly created by most end users.</p><p>If <code>models::QuantRegModels</code> contained models with <code>τ</code>=0.25, 0.5 and 0.75, these models could be accessed as <code>models[0.25], models[0.5],</code> and <code>models[0.75]</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L316-L327">source</a></section></article><h3 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h3><p>As a hybrid of an array and a dictionary, some methods intended for arrays and some intended for dictionaries are implemented for <code>QuantRegModels</code>.</p><p>For example, to add a new model to a <code>QuantRegModels</code> object, one should use <code>append!</code>. This method ensures that the underlying dictionary exclusively contains <code>QuantRegModel</code> objects, that the models are indexed by their τ values, and that each <code>QuantRegModels</code> object contains no more than one <code>QuantRegModel</code> for a given τ value. </p><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Tuple{QuantReg.QuantRegModels,QuantRegModel}" href="#Base.append!-Tuple{QuantReg.QuantRegModels,QuantRegModel}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append!(X::QuantRegModels, model::QuantRegModel)</code></pre><p>Add <code>model</code> to <code>X</code> in-place</p><p>Throws an error if <code>X</code> already contains a model with the same τ value as <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L361-L367">source</a></section></article><p>A <code>getindex</code> method is implemented for this type so that users can access a particular model via the following syntax:</p><pre><code class="language-none">julia&gt; models[τ]</code></pre><p>where models is a <code>QuantRegModels</code> object and τ is a τ value for a <code>QuantRegModel</code> stored in models.</p><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{QuantReg.QuantRegModels,Number}" href="#Base.getindex-Tuple{QuantReg.QuantRegModels,Number}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(X::QuantRegModels, τ::Number)</code></pre><p>Returns the model in <code>X</code> at the τth quantile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L347-L351">source</a></section></article><p>There are also two methods, <code>taus</code> and <code>hastau</code>, which respectively display all the τ values for which a <code>QuantRegModels</code> object contains a model and checks whther a given <code>QuantRegModels</code> object contains a model for a specific value of τ.</p><article class="docstring"><header><a class="docstring-binding" id="QuantReg.taus" href="#QuantReg.taus"><code>QuantReg.taus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">taus(X::QuantRegModels)</code></pre><p>Retrive all the <code>τ</code> values for models stored in <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantReg.hastau" href="#QuantReg.hastau"><code>QuantReg.hastau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex(X::QuantRegModels, τ::Number)</code></pre><p>Check if <code>X</code> contains a model at the τth quantile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L354-L358">source</a></section></article><p>Lastly, there is also an implementation of <code>show</code> which nicely displays all the models stored in a <code>QuantRegModels</code> object.</p><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,QuantReg.QuantRegModels}" href="#Base.show-Tuple{IO,QuantReg.QuantRegModels}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, models:QuantRegModels)</code></pre><p>Display each model in <code>models</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fogarty-ben/QuantReg.jl/blob/e4b28153fa3f0c533141048a9489429fc9da3d4e/src/qrmodel.jl#L335-L339">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quickstart</a><a class="docs-footer-nextpage" href="../fitting/">Fitting models »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 12 April 2020 19:09">Sunday 12 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
